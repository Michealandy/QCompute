<!DOCTYPE html><html><head>
      <title>Shor_EN</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({"extensions":["tex2jax.js"],"jax":["input/TeX","output/HTML-CSS"],"messageStyle":"none","tex2jax":{"processEnvironments":false,"processEscapes":true,"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"TeX":{"extensions":["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]},"HTML-CSS":{"availableFonts":["TeX"]}});
        </script>
        <script type="text/javascript" async src="file:///c:\Users\chenyuao\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.5.21\node_modules\@shd101wyy\mume\dependencies\mathjax\MathJax.js" charset="UTF-8"></script>
        
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
body {
  text-align: left;
}
body h1,
body h2,
body h3 {
  text-align: center;
}
body h4,
body h5,
body h6,
body p,
body section {
  text-align: left;
}

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="shors-algorithm">Shor&apos;s Algorithm</h1>

<h2 class="mume-header" id="preface">Preface</h2>

<p><strong>Integer Factorization</strong> denotes a decomposition of a given positive integer <span class="mathjax-exps">$N$</span> as a product of several smaller positive integers (greater than 1), such as <span class="mathjax-exps">$45=5\times9$</span>.</p>
<p><strong>Shor&apos;s Algorithm</strong> is a quantum algorithm proposed by Shor in 1994<span class="mathjax-exps">$^{[2]}$</span>, which can give the integer factorization of <span class="mathjax-exps">$N$</span> in time</p>
<p></p><div class="mathjax-exps">$$O\left((\log N)^2(\log \log N)(\log \log \log N)\right).\tag{1}$$</div><p></p>
<p>Here we will show Shor&apos;s algorithm in three sections. Firstly, we will show the framework of Shor&apos;s algorithm, referring to section <strong>Overview of Shor&apos;s Algorithm</strong> for details. That introduces two core steps of Shor&apos;s algorithm: reducing factorizations into orders finding and the quantum order-finding algorithm, referring to sections <strong>From Integer Factorization to Order-Finding</strong> and <strong>Quantum Order-Finding Algorithm</strong> for details, respectively. In the final of these two sectinos, we given OPENQASM and QCompute codes to factor integers <span class="mathjax-exps">$15$</span> and <span class="mathjax-exps">$63$</span> for readers to try. Since the methods above are of less generality, we can&apos;t use these to factor all integers. To overcome these problem, we give the code for the alogrithm in reference [7] for readers to try and study, referring to section <strong>Implements of Gate <span class="mathjax-exps">$C(U_{a,N})$</span></strong> for more details.</p>
<ul>
<li><a href="#shors-algorithm">Shor&apos;s Algorithm</a>
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#overview-of-shors-algorithm">Overview of Shor&apos;s Algorithm</a></li>
<li><a href="#from-integer-factorization-to-order-finding">From Integer Factorization to Order-Finding</a></li>
<li><a href="#quantum-order-finding-algorithm">Quantum Order-Finding Algorithm</a>
<ul>
<li><a href="#theory">Theory</a>
<ul>
<li><a href="#encoding-the-order-into-eigen-phase">Encoding the Order into Eigen Phase</a></li>
<li><a href="#continued-fraction-expansion-decodes-eigen-phases-into-orders">Continued Fraction Expansion Decodes eigen phases into Orders</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
<li><a href="#simple-examples-and-experiments">Simple Examples and Experiments</a>
<ul>
<li><a href="#find-rm-ord215-and-factor-15">Find <span class="mathjax-exps">${\rm ord}(2,15)$</span> and Factor <span class="mathjax-exps">$15$</span></a></li>
<li><a href="#find-rm-ord263-and-factor-63">Find <span class="mathjax-exps">${\rm ord}(2,63)$</span> and Factor <span class="mathjax-exps">$63$</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#implements-of-gate-cu_an">Implements of Gate <span class="mathjax-exps">$C(U_{a,N})$</span></a>
<ul>
<li><a href="#reversible-calculation">Reversible Calculation</a>
<ul>
<li><a href="#from-classical-reversible-calculation-on">From (Classical) Reversible Calculation on</a></li>
<li><a href="#go-back-to-gates-u_an">Go Back to Gates <span class="mathjax-exps">$U_{a,N}$</span></a></li>
</ul>
</li>
<li><a href="#implements-of-general-cu_an-gates">Implements of General <span class="mathjax-exps">$C(U_{a,N})$</span> Gates</a>
<ul>
<li><a href="#implements-of-~phi_la">Implements of <span class="mathjax-exps">$~\Phi$</span><span class="mathjax-exps">$_{L,+a}$</span></a></li>
<li><a href="#implements-of-c2phi_latextmod-n">Implements of <span class="mathjax-exps">$C^2(\Phi_{L,+a,\text{mod }N})$</span></a></li>
<li><a href="#implements-of-u_lacdottext-mod-n">Implements of <span class="mathjax-exps">$U_{L,+a\cdot\text{ mod }N}$</span></a></li>
<li><a href="#implements-of-u_an">Implements of <span class="mathjax-exps">$U_{a,N}$</span></a></li>
<li><a href="#implements-of-quantum-order-finding-algorithm">Implements of Quantum Order-Finding Algorithm</a></li>
<li><a href="#implements-of-shors-algorithm">Implements of Shor&apos;s Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<h2 class="mume-header" id="overview-of-shors-algorithm">Overview of Shor&apos;s Algorithm</h2>

<p>Shor&apos;s algorithm can be considered as a quantum improvement of an classical algorithm for integer factorization (the ideas came from [1]):</p>
<ol>
<li>both algorithms transfer the integer factorization into Order-Finding;</li>
<li>Shor proposes the Quantum Order-Finding Algorithm, which achieves <strong>exponential speedup</strong>;</li>
<li>replace the Order-Finding algorithm by the quantum one, and we will obtain a quantum improvement, namely Shor&apos;s algorithm.</li>
</ol>
<p>We will introduce the transfer procedure (from integer factorization to order-finding), the quantum order-finding algorithm, and code examples of them in Quantum Leaf successively. However, we haven&apos;t given a general method to factor any integer, because of the key problem how to implement the <strong>Oracle</strong> (quantum blackbox) efficiently. We will present an idea on implementing the oracle by (classical) <strong>Reversible Calculation</strong> in the first half of the last subsection, and the Quantum Leaf code of the implement in the other half for readers to learn.</p>
<h2 class="mume-header" id="from-integer-factorization-to-order-finding">From Integer Factorization to Order-Finding</h2>

<p>In this section, we will show a way to transfer integer factorization into order-finding. As a result of that, as long as we solve order-finding, we can give a factorization of corresponding integer.</p>
<p>Some basic mathematical background knowledge is required to read the following contents of this tutorial:</p>
<ol>
<li>Given two integers <span class="mathjax-exps">$N,a$</span>, if <span class="mathjax-exps">$N/a$</span> is also an integer, we say <span class="mathjax-exps">$a$</span> <strong>divides</strong> <span class="mathjax-exps">$N$</span>,<span class="mathjax-exps">$a$</span> is a <strong>factor</strong> of <span class="mathjax-exps">$N$</span>, denoted as <span class="mathjax-exps">$a\,|\,N$</span>; otherwise, it is denoted as <span class="mathjax-exps">$a\nmid N$</span>;</li>
<li>The <strong>nontrivial</strong> factors of <span class="mathjax-exps">$N$</span> are those factors except <span class="mathjax-exps">$\pm 1$</span> and <span class="mathjax-exps">$\pm N$</span>; <strong>Integer factorization</strong> can also be considered as nontrivial factors solving;</li>
<li>The <strong>Greatest Common Divisor</strong> (GCD) of several integers is defined as the maximal integers which divides each of these integers, denoted as <span class="mathjax-exps">${\rm gcd}(\cdot,\cdots,\cdot)$</span>, which can be computed by <a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fr=aladdin"><strong>Euclidean algorithm</strong></a> effectively; We say two integers <strong>coprime</strong> if their GCD is <span class="mathjax-exps">$1$</span>;</li>
<li>Given integers <span class="mathjax-exps">$a,b,N$</span>, we say <span class="mathjax-exps">$a$</span> and <span class="mathjax-exps">$b$</span> are congruent modulo <span class="mathjax-exps">$N$</span> if <span class="mathjax-exps">$N|(a-b)$</span>, denoted as <span class="mathjax-exps">$a\equiv b\pmod{N}$</span>; otherwise, it is denoted as <span class="mathjax-exps">$a\not\equiv b\pmod{N}$</span>;</li>
<li>Given two integers <span class="mathjax-exps">$a$</span> and <span class="mathjax-exps">$N$</span>, we say <span class="mathjax-exps">$r$</span> is the <strong>(multiplicative) order</strong> of <span class="mathjax-exps">$a$</span> modulo <span class="mathjax-exps">$N$</span> if <span class="mathjax-exps">$r$</span> is the minimal positive integer such that <span class="mathjax-exps">$a^r\equiv 1\pmod{N}$</span>, denoted as <span class="mathjax-exps">$r={\rm ord}(a,N)$</span>; We say <span class="mathjax-exps">$a$</span> and <span class="mathjax-exps">$N$</span> the <strong>base</strong> and the <strong>modulus</strong> of <span class="mathjax-exps">$r$</span>.</li>
</ol>
<p>If we know an integer <span class="mathjax-exps">$a$</span> and its order <span class="mathjax-exps">$r$</span> modulo <span class="mathjax-exps">$N$</span>, then we have <span class="mathjax-exps">$N\,|\,(a^r-1)$</span>. Now assume that <span class="mathjax-exps">$r$</span> is even (say <span class="mathjax-exps">$2\,|\,r$</span>), and then we have <span class="mathjax-exps">$N\,|\,(a^{r/2}-1)(a^{r/2}+1)$</span> by the formula for the difference of square. We know that <span class="mathjax-exps">$N\nmid(a^{r/2}-1)$</span> by the minimality in the definition of the orders. Now further assume that <span class="mathjax-exps">$N\nmid(a^{r/2}+1)$</span>, i.e. <span class="mathjax-exps">$a^{r/2}\not\equiv-1\pmod{N}$</span>, then we have <span class="mathjax-exps">$N\nmid(a^{r/2}\pm1)$</span> but <span class="mathjax-exps">$N\mid(a^{r/2}-1)(a^{r/2}+1)$</span>. Thus it can be proved that <span class="mathjax-exps">${\rm gcd}(N,a^{r/2}\pm1)$</span> are both nontrivial factors of <span class="mathjax-exps">$N$</span>. In summary, if we have a pair <span class="mathjax-exps">$(a,r)$</span> satisfying above conditions, we can find a nontrivial factor of <span class="mathjax-exps">$N$</span> effectively (equivalently, we have a factorization of <span class="mathjax-exps">$N$</span>). To simplify the expression, writers give the above conditions a title (not general formal):</p>
<div class="theorem">
<p><strong>Definition 1 (Inducer).</strong> Given two coprime integers <span class="mathjax-exps">$a$</span> and <span class="mathjax-exps">$N$</span> with <span class="mathjax-exps">$2\nmid N$</span> (say <span class="mathjax-exps">$N$</span> is odd), denote <span class="mathjax-exps">$r={\rm ord}(a,N)$</span>. We call <span class="mathjax-exps">$a$</span> an <strong>inducer modulo</strong> <span class="mathjax-exps">$N$</span> if <span class="mathjax-exps">$r$</span> is even and <span class="mathjax-exps">$a^{r/2}\not\equiv-1\pmod{N}$</span>.</p>
</div>
<p>We have known an inducer <span class="mathjax-exps">$a$</span> and its order <span class="mathjax-exps">$r$</span> can induce an integer factorization of <span class="mathjax-exps">$N$</span>, but it is unresolved how to find an inducer and how to compute the order. However if we have an algorithm to compute orders effectively, then we can select <span class="mathjax-exps">$a$</span> randomly, then compute its order, and then determine whether <span class="mathjax-exps">$a$</span> is an inducer. If so,we can give a factorization of <span class="mathjax-exps">$N$</span> through <span class="mathjax-exps">${\rm gcd}(N,a^{r/2}\pm1)$</span>; otherwise, we can re-select <span class="mathjax-exps">$a$</span> and repeat the above procedure. Especially, if we have selected an integer <span class="mathjax-exps">$a$</span> not coprime with <span class="mathjax-exps">$N$</span>, although the order of <span class="mathjax-exps">$a$</span> doesn&apos;t exist, <span class="mathjax-exps">${\rm gcd}(a,N)$</span> has been a nontrivial factor of <span class="mathjax-exps">$N$</span>. Meanwhile we do not need the order-finding step to obtain the factorization of <span class="mathjax-exps">$N$</span>.</p>
<div class="theorem">
<p><strong>Example 2.</strong> Let <span class="mathjax-exps">$N=315$</span>, <span class="mathjax-exps">$a=2$</span>. It can be proved that <span class="mathjax-exps">${\rm ord}(2,315)=12$</span> and <span class="mathjax-exps">$2^{12/2}\equiv 64\not\equiv-1\pmod{315}$</span>. Thus <span class="mathjax-exps">$2$</span> is an inducer modulo <span class="mathjax-exps">$315$</span>, both <span class="mathjax-exps">${\rm gcd}(2^{6}-1,315)=63$</span> and <span class="mathjax-exps">${\rm gcd}(2^{6}+1,315)=5$</span> are nontrivial factors of <span class="mathjax-exps">$315$</span>. Especially, we have <span class="mathjax-exps">$315=63\times5$</span> exactly.</p>
</div>
<p>We will expand the step of order-finding in the next section, which is the only quantum part in Shor&apos;s algorithm. As the last of this section, we summary the procedure of Shor&apos;s algorithm as following:</p>
<div class="theorem">
<p><strong>Algorithm 3 (Shor&apos;s algorithm).</strong></p>
<p><strong>Input:</strong> a positive odd <span class="mathjax-exps">$N$</span> which has two coprime nontrivial factors.</p>
<p><strong>Output:</strong> an nontrivial factor of <span class="mathjax-exps">$N$</span>.</p>
<ol>
<li>Select <span class="mathjax-exps">$a$</span> in <span class="mathjax-exps">$\{2,3,\cdots,N-2\}$</span> randomly;</li>
<li>Use <a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fr=aladdin">Euclidean algorithm</a> to compute <span class="mathjax-exps">${\rm gcd}(a,N)$</span>;</li>
<li><strong>if</strong> <span class="mathjax-exps">${\rm gcd}(a,N)\ne1$</span>, <strong>return</strong> <span class="mathjax-exps">${\rm gcd}(a,N)$</span>;</li>
<li>Use (quantum) order-finding algorithm to compute <span class="mathjax-exps">$r={\rm ord}(a,N)$</span>;</li>
<li><strong>if</strong> <span class="mathjax-exps">$r$</span> is even <strong>and</strong> <span class="mathjax-exps">$a^{r/2}\not\equiv -1\pmod{N}$</span>,<strong>return</strong> <span class="mathjax-exps">${\rm gcd}(a^{r/2}+1,N)$</span> (or <span class="mathjax-exps">${\rm gcd}(a^{r/2}-1,N)$</span>);</li>
<li><strong>goto</strong> step 1.</li>
</ol>
</div>
<h2 class="mume-header" id="quantum-order-finding-algorithm">Quantum Order-Finding Algorithm</h2>

<h3 class="mume-header" id="theory">Theory</h3>

<p>Since the algorithm is to find the order of <span class="mathjax-exps">$a$</span> modulo <span class="mathjax-exps">$N$</span>, we call it quantum order-finding algorithm. It can be proved that</p>
<p></p><div class="mathjax-exps">$$f(x)= a^x\text{ mod }{N}\tag{2}$$</div><p></p>
<p>is a period function, whose (minimum positive) period is <span class="mathjax-exps">${\rm ord}(a,N)$</span> exactly, where <span class="mathjax-exps">$x \text{ mod }y:=x-y\lfloor x/y\rfloor\in\{0,\cdots,y-1\}$</span> is the remainder of <span class="mathjax-exps">$x$</span> divided by <span class="mathjax-exps">$y$</span>. Then, quantum order-finding algorithm can be considered as a special case for the <strong>Quantum Period-Finding Algorithm</strong>. In essence, quantum phase estimation algorithm is also a special case for quantum period-finding algorithm, but it is more difficult to understand order-finding and phase estimation through period-finding. Here interested readers may refer to [5].</p>
<p>Now we can consider that Shor&apos;s order-finding algorithm is based on thg phase estimation algorithm:</p>
<ol>
<li><strong>encode</strong> the order into the eigen phase of some quantum gate (or circuit);</li>
<li>use quantum phase estimation algorithm to <strong>estimate</strong> the eigen phase;</li>
<li>use the continued fraction expansion algorithm to <strong>decode</strong> the value of order.</li>
</ol>
<h4 class="mume-header" id="encoding-the-order-into-eigen-phase">Encoding the Order into Eigen Phase</h4>

<p>Given <span class="mathjax-exps">$a\in\{2,\cdots,N-2\}$</span> coprime with <span class="mathjax-exps">$N$</span>, our goal is to solve <span class="mathjax-exps">$r={\rm ord}(a,N)$</span>.Introducing <span class="mathjax-exps">$L=\lceil \log_2(N+1)\rceil$</span> qubits to encode the quantum states <span class="mathjax-exps">$|0\rangle,|1\rangle,\cdots,|N-1\rangle$</span>, set a quantum gate</p>
<p></p><div class="mathjax-exps">$$U_{a,N}=\sum_{x=0}^{N-1}|{ax\ \textrm{mod } {N}}\rangle\langle{x}|+\sum_{x=N}^{2^L-1}|{x}\rangle\langle{x}|.\tag{3}$$</div><p></p>
<p>It can be proved that <span class="mathjax-exps">$|1\rangle$</span> is an average superposition state of some eigenstates of <span class="mathjax-exps">$U_{a,N}$</span>. Operating the quantum phase estimation algorithm on the state <span class="mathjax-exps">$|1\rangle$</span> and the quantum gate <span class="mathjax-exps">$U_{a,N}$</span>, we will obtain an approximation of</p>
<p></p><div class="mathjax-exps">$$s/r, \ s=0,1,\cdots,r-1,\tag{4}$$</div><p></p>
<p>with <span class="mathjax-exps">$2\pi s/r$</span> an eigen phase of <span class="mathjax-exps">$U_{a,N}$</span>. When the precision of quantum phase estimation algorithm is less than <span class="mathjax-exps">$N^{-2}$</span>, we can use continued fraction expansion algorithm to recovery <span class="mathjax-exps">$r$</span> from the approximation.</p>
<h4 class="mume-header" id="continued-fraction-expansion-decodes-eigen-phases-into-orders">Continued Fraction Expansion Decodes eigen phases into Orders</h4>

<p>Here we demonstrate the continued fraction expansion algorithm through an example. It is clear to see that the continued fraction expansion algorithm is just a deformation of Euclidean algorithm: in each iteration we reform the fraction as a mixed fraction, reduce the numerator into <span class="mathjax-exps">$1$</span>, and input the new denominator into next iteration until the denominator is an integer.</p>
<div class="theorem">
<p><strong>Example 4.</strong> Set <span class="mathjax-exps">$N=63$</span>, <span class="mathjax-exps">$k=2729/8192$</span>. We have the continued fraction expansion for <span class="mathjax-exps">$k$</span>:</p>
<p></p><div class="mathjax-exps">$$\begin{align*} \frac{2729}{8192} =&amp;\frac{1}{\frac{8192}{2729}}=\frac{1}{3+\frac{5}{2729}}=\frac{1}{3+\frac{1}{\frac{2729}{5}}}=\frac{1}{3+\frac{1}{545+\frac45}}\\ =&amp;0 + \frac{1}{3+\frac{1}{545+\frac{1}{1+\frac{1}{4}}}}=:[0,3,545,1,4]. \end{align*}\tag{5}$$</div><p></p>
<p>We call <span class="mathjax-exps">$[0]=0$</span>,<span class="mathjax-exps">$[0,3]=0+\frac{1}{3}=\frac{1}{3}$</span>,<span class="mathjax-exps">$[0,3,545]=0+\frac{1}{3+\frac{1}{545}}=\frac{545}{1636}$</span> and <span class="mathjax-exps">$[0,3,545,1]=0+\frac{1}{3+\frac{1}{545+\frac{1}{1}}}=\frac{546}{1639}$</span> the <span class="mathjax-exps">$0$</span>th, <span class="mathjax-exps">$1$</span>st, <span class="mathjax-exps">$2$</span>nd and <span class="mathjax-exps">$3$</span>rd <strong>convergent</strong> of continued fraction <span class="mathjax-exps">$[0,3,545,1,4]$</span>. The continued fraction expansion algorithm <strong>returns</strong> the maximal denominator less than <span class="mathjax-exps">$N$</span> of each convergent of <span class="mathjax-exps">$k$</span>, which is <span class="mathjax-exps">$3$</span> in this example.</p>
</div> 
<div class="theorem">
<p><strong>Remark 5.</strong> When the precision of quantum phase estimation algorithm is less than <span class="mathjax-exps">$N^{-2}$</span>, the continued fraction expansion algorithm will return the denominator of <span class="mathjax-exps">$s/r$</span>. However, the denominator of <span class="mathjax-exps">$s/r$</span> may not be <span class="mathjax-exps">$r$</span>: when <span class="mathjax-exps">${\rm gcd}(s,r)\ne1$</span>, the denominator of <span class="mathjax-exps">$s/r$</span> is <span class="mathjax-exps">$r/{\rm gcd}(s,r)$</span>. Meanwhile the probability of recovering the correct order is related to <span class="mathjax-exps">$N$</span>, but trending to <span class="mathjax-exps">$0$</span> for the worst case.</p>
</div> 
<p>In order to increase the probability of recovering the order, the best method is operating the above algorithm twice, and returning the least common multiple of the two returns:</p>
<div class="theorem">
<p><strong>Theorem 6.</strong> By calling the quantum order-finding algorithm twice, we can obtain two denominators <span class="mathjax-exps">$q$</span> and <span class="mathjax-exps">$q&apos;$</span>. Compute the least common multiple of them <span class="mathjax-exps">$\tilde r:=q q&apos;/\textrm{gcd}(q,q&apos;)$</span>, and then the probability of <span class="mathjax-exps">$\tilde r=r$</span> is greater than <span class="mathjax-exps">${6(1-\epsilon)^2}/{\pi^2} \ge60.7\%\cdot(1-\epsilon)^2$</span>, where <span class="mathjax-exps">$\epsilon$</span> is the failure probability of the phase estimation algorithm. Here <span class="mathjax-exps">$q$</span> and <span class="mathjax-exps">$q&apos;$</span> are returns of continued fraction expansion algorithm with <span class="mathjax-exps">$k$</span> and <span class="mathjax-exps">$k&apos;$</span> of as inputs, respectively, where <span class="mathjax-exps">$k$</span> and <span class="mathjax-exps">$k&apos;$</span> are the two returns of quantum phase estimation algorithm.</p>
</div>
<h4 class="mume-header" id="summary">Summary</h4>

<p>At the last of this section, we summary the quantum order-finding algorithm.</p>
<div class="theorem">
<p><strong>Algorithm 7 (Quantum order-finding algorithm.).</strong></p>
<p><strong>Input:</strong> Integer <span class="mathjax-exps">$a\in\{2,\cdots,N-2\}$</span> coprime with <span class="mathjax-exps">$N$</span>, the failure probability of quantum phase estimation <span class="mathjax-exps">$\epsilon$</span>.</p>
<p><strong>Output:</strong> <span class="mathjax-exps">${\rm ord}(a,N)$</span>.</p>
<ol>
<li>Set <span class="mathjax-exps">$L=\lceil \log_2(N+1)\rceil$</span>;</li>
<li>Call twice: using <span class="mathjax-exps">$t=2L+1+\lceil\log_2(1+\frac{2}{\epsilon\pi^2})\rceil$</span> qubits as the ancilla register to operate the quantum phase estimation algorithm on the quantum gate <span class="mathjax-exps">$U_{a,N}$</span> and quantum state <span class="mathjax-exps">$|1\rangle$</span> and measuring the ancilla register. Obtain two quantum state <span class="mathjax-exps">$|m\rangle$</span> and <span class="mathjax-exps">$|m&apos;\rangle$</span>, respectively;</li>
<li>Operate the continued fraction expansion algorithm on <span class="mathjax-exps">$k=2^{-t}m$</span> and <span class="mathjax-exps">$k&apos;=2^{-t}m&apos;$</span> and find the maximal denominator less than <span class="mathjax-exps">$N$</span> of each convergent <span class="mathjax-exps">$q_j$</span> &#x548C; <span class="mathjax-exps">$q_k&apos;$</span>, respectively;</li>
<li>Setting <span class="mathjax-exps">$r_{jk}=q_jq_k&apos;/{\rm gcd}(q_j,q_k&apos;)$</span>, <strong>if</strong> <span class="mathjax-exps">$a^{r_{jk}}\equiv 1\pmod N$</span> <strong>return</strong> <span class="mathjax-exps">${\rm ord}(a,N)=r_{jk}$</span>; <strong>else</strong> <strong>goto</strong> step 2 and restart the computation.</li>
</ol>
</div>
<p>Here the probability of returning <span class="mathjax-exps">${\rm ord}(a,N)$</span> in the step 4 of algorithm 7 is greater than <span class="mathjax-exps">$60.7\%\cdot(1-\epsilon)^2$</span>. Especially, set <span class="mathjax-exps">$t=2L+1+3$</span>, <span class="mathjax-exps">$\epsilon=2.895\%$</span>, the probability is greater than <span class="mathjax-exps">$57.3\%$</span>. Meanwhile, the probability of finding the correct order is greater than <span class="mathjax-exps">$96.6\%$</span> for four iterations.</p>
<p>Thus, we have shown all content of Shor&apos;s algorithm, and will demonstration two simple example in the next subsection.</p>
<h3 class="mume-header" id="simple-examples-and-experiments">Simple Examples and Experiments</h3>

<p>In this subsection, we will show Shor&apos;s algorithm in <a href="https://quantum-hub.baidu.com/#/">Quantum Leaf</a>. Firstly, we use QComposer to solve the order of <span class="mathjax-exps">$2$</span> modulo <span class="mathjax-exps">$15$</span> and thus give a factorization of <span class="mathjax-exps">$15$</span>. Secondly, we use PyOnline to solve the order of <span class="mathjax-exps">$2$</span> modulo <span class="mathjax-exps">$63$</span> and thus give a factorization of <span class="mathjax-exps">$63$</span>.</p>
<h4 class="mume-header" id="find-rm-ord215-and-factor-15">Find <span class="mathjax-exps">${\rm ord}(2,15)$</span> and Factor <span class="mathjax-exps">$15$</span></h4>

<p><span class="mathjax-exps">$L=\lceil \log_2(15+1)\rceil=4$</span> qubits are needed to encode the quantum gate <span class="mathjax-exps">$U_{2,15}$</span> (abbreviated as <span class="mathjax-exps">$U$</span> in this subsection):</p>
<p></p><div class="mathjax-exps">$$U_{2,15}=\left[\begin{array}{cccccccccccccccc} 1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1 \end{array}\right].\tag{6}$$</div><p></p>
<p>A decomposition of <span class="mathjax-exps">$C(U_{2,15})$</span> is shown as following, where the <span class="mathjax-exps">$0$</span>th qubit is the controlling qubit, and the <span class="mathjax-exps">$1$</span>st, <span class="mathjax-exps">$2$</span>nd, <span class="mathjax-exps">$3$</span>rd and <span class="mathjax-exps">$4$</span>th qubit are the target qubits of <span class="mathjax-exps">$U_{2,15}$</span> in sequence:</p>
<p><img src="figures/CU_2_15.png" alt></p>
<p>The corresponding OPENQASM code is following:</p>
<pre data-role="codeBlock" data-info="cpp{.line-numbers}" class="language-cpp line-numbers">OPENQASM <span class="token number">2.0</span><span class="token punctuation">;</span>
include <span class="token string">&quot;qelib1.inc&quot;</span><span class="token punctuation">;</span>
qreg q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
creg c<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>which can be represented as</p>
<p></p><div class="mathjax-exps">$$\begin{align*}C(U_{2,15})&amp;= \operatorname{CSWAP}_{0,3,4}\cdot\operatorname{CSWAP}_{0,2,3}\cdot\operatorname{CSWAP}_{0,1,2},\tag{7}\end{align*}$$</div><p></p>
<p>where <span class="mathjax-exps">$\operatorname{CSWAP}_{j,k,l}$</span> is a <span class="mathjax-exps">$\operatorname{CSWAP}$</span> gate with the <span class="mathjax-exps">$j$</span>-th qubit as controlling qubit and the <span class="mathjax-exps">$k$</span>-th and <span class="mathjax-exps">$l$</span>-th qubit as target qubits. Other <span class="mathjax-exps">$C(U_{2,15}^{2^j})$</span> gate are needed in the quantum phase estimation algorithm:</p>
<p></p><div class="mathjax-exps">$$\begin{align*}C(U_{2,15}^2)&amp;= \operatorname{CSWAP}_{0,2,4}\cdot \operatorname{CSWAP}_{0,1,3};\tag{8}\\ C(U_{2,15}^{2^j}) &amp;= I,\quad j\ge3.\tag{9}\end{align*}$$</div><p></p>
<p>Using <span class="mathjax-exps">$2L+1=9$</span> qubits as the ancilla register to estimate the eigen phase of <span class="mathjax-exps">$|0001\rangle$</span>, the quantum circuit of that in QComposer is shown in the following figure (where we omit those omissible <span class="mathjax-exps">$I$</span> gates):</p>
<p><img src="figures/OrderFinding_2_15.png" alt="the circuit for finding  in QComposer"></p>
<p>The corresponding OPENQASM <a href="https://quantum-hub.baidu.com/#/">code</a> is following:</p>
<pre data-role="codeBlock" data-info="cpp{.line-numbers}OPENQASM 2.0;" class="language-cpp line-numbers">include <span class="token string">&quot;qelib1.inc&quot;</span><span class="token punctuation">;</span>
qreg q<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// q[0],...,q[8] are ancilla register, q[9],...,q[12] are system register</span>
creg c<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
x q<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Prepare the initial state |0&gt;|1&gt;, and will operate the Quantum Phase Estimation algorithm (QPE)</span>
<span class="token comment">// The first step of QPE where we prepare an average superposition state</span>
h q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">// An implement of C(U) with q[8] as the controlling qubit</span>
cswap q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">// An implement of C(U^2) with q[7] as the controlling qubit</span>
cswap q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cswap q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">// Omit other C(U^(2^j)) gates equal to I</span>
<span class="token comment">// Operate inversed Fourier tranform on the ancilla register</span>
<span class="token comment">// The SWAP step in inversed Fourier tranform</span>
swap q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
swap q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
swap q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
swap q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// The control-rotation step in inversed Fourier tranform</span>
h q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">128</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">256</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">128</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">cu</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
h q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">// The inversed Fourier tranform is completed</span>
<span class="token comment">// Measurement</span>
measure q<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
measure q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>The results of a run are as follows:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token punctuation">{</span>
    <span class="token string">&quot;000000011&quot;</span><span class="token punctuation">:</span> <span class="token number">237</span><span class="token punctuation">,</span>
    <span class="token string">&quot;000000010&quot;</span><span class="token punctuation">:</span> <span class="token number">257</span><span class="token punctuation">,</span>
    <span class="token string">&quot;000000000&quot;</span><span class="token punctuation">:</span> <span class="token number">269</span><span class="token punctuation">,</span>
    <span class="token string">&quot;000000001&quot;</span><span class="token punctuation">:</span> <span class="token number">261</span>
<span class="token punctuation">}</span>
</pre><p>About equal frequency<br>
We can see that the measurement are <span class="mathjax-exps">$|000000000\rangle$</span>, <span class="mathjax-exps">$|010000000\rangle$</span>, <span class="mathjax-exps">$|100000000\rangle$</span> and <span class="mathjax-exps">$|110000000\rangle$</span> of about equal frequency, which are corresponding to fractions <span class="mathjax-exps">$0$</span>, <span class="mathjax-exps">$1/4$</span>, <span class="mathjax-exps">$1/2$</span> and <span class="mathjax-exps">$3/4$</span>. Here the continued fraction expansion of <span class="mathjax-exps">$3/4$</span> is</p>
<p></p><div class="mathjax-exps">$$\frac{3}{4}=\frac{1}{1+\frac{1}{3}},\tag{10}$$</div><p></p>
<p>whose <span class="mathjax-exps">$1$</span>st convergent is <span class="mathjax-exps">$1$</span>&#x3002;</p>
<p>Thus we have probability about <span class="mathjax-exps">$1/2$</span> to obtain <span class="mathjax-exps">${\rm ord}(2,15)=4$</span> correctly in each call of quantum phase estimation algorithm, and <span class="mathjax-exps">$3/4$</span> in each two calls. Since <span class="mathjax-exps">$2^{4/2} = 4\not\equiv -1\pmod{15}$</span>, we have <span class="mathjax-exps">$15|(4-1)(4+1)$</span> induces a factorization of <span class="mathjax-exps">$15$</span>:</p>
<p></p><div class="mathjax-exps">$$15=\textrm{gcd}(15,4-1)\times\textrm{gcd}(15,4+1)=3\times5.\tag{11}$$</div><p></p>
<p>Now the show is done that using Shor&apos;s algorithm to factor <span class="mathjax-exps">$15$</span>.</p>
<p>Afterword: It is not a general method to omit <span class="mathjax-exps">$C(U^{2^j})$</span> gates equal to <span class="mathjax-exps">$I$</span> in the above OPENQASM code, because of rejecting what is near at hand and seeking what is far away. The right way is to decompose those gates by a general method instead of to prove it equal to <span class="mathjax-exps">$I$</span>. In the next subsection we will avoid this when showing the factorization of <span class="mathjax-exps">$63$</span>.</p>
<h4 class="mume-header" id="find-rm-ord263-and-factor-63">Find <span class="mathjax-exps">${\rm ord}(2,63)$</span> and Factor <span class="mathjax-exps">$63$</span></h4>

<p><span class="mathjax-exps">$L=\lceil \log_2(63+1)\rceil=6$</span> qubits are needed to encode the quantum gate <span class="mathjax-exps">$U_{2,63}$</span> (also abbreviated as <span class="mathjax-exps">$U$</span> in this subsection). We will introduce <span class="mathjax-exps">$2L+1=13$</span> qubits as the ancilla register to estimate the eigen phase. Considering <span class="mathjax-exps">$j&gt;0$</span> implies</p>
<p></p><div class="mathjax-exps">$$U^{2^j}=U^{2^{j\rm{\ mod\ }2}},\tag{12}$$</div><p></p>
<p>we only need to implement quantum gates <span class="mathjax-exps">$C(U)$</span>, <span class="mathjax-exps">$C(U^{2})$</span> and <span class="mathjax-exps">$C(U^{4})$</span>:</p>
<p></p><div class="mathjax-exps">$$\begin{align*} C(U)&amp;= \operatorname{CSWAP}_{0,1,2}\cdot\operatorname{CSWAP}_{0,2,3}\cdot\operatorname{CSWAP}_{0,3,4}\cdot\operatorname{CSWAP}_{0,4,5}\cdot\operatorname{CSWAP}_{0,5,6};\tag{13}\\ C(U^2)&amp;= \operatorname{CSWAP}_{0,3,5}\cdot \operatorname{CSWAP}_{0,1,3}\cdot\operatorname{CSWAP}_{0,4,6}\cdot \operatorname{CSWAP}_{0,2,4};\tag{14}\\ C(U^{4}) &amp;=\operatorname{CSWAP}_{0,1,3} \cdot \operatorname{CSWAP}_{0,3,5}\cdot\operatorname{CSWAP}_{0,2,4}\cdot \operatorname{CSWAP}_{0,4,6}.\tag{15} \end{align*}$$</div><p></p>
<p>The <a href="https://quantum-hub.baidu.com/#/">PyOnline</a> code is following:</p>
<pre data-role="codeBlock" data-info="python{.numberLines}" class="language-python line-numbers"><span class="token keyword">from</span> QCompute <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">from</span> numpy <span class="token keyword">import</span> pi


<span class="token keyword">def</span> <span class="token function">func_order_finding_2_mod_63</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    This function will give an approximation related to the eigen phase s/6 for some s=0,1,2,3,4,5
    where 6 is the order of 2 mod 63.
    &quot;&quot;&quot;</span>
    env <span class="token operator">=</span> QEnv<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Create environment</span>
    env<span class="token punctuation">.</span>backend<span class="token punctuation">(</span>BackendName<span class="token punctuation">.</span>LocalBaiduSim2<span class="token punctuation">)</span>  <span class="token comment"># Choose backend Baidu Local Quantum Simulator-Sim2</span>

    L <span class="token operator">=</span> <span class="token number">6</span>  <span class="token comment"># The number of qubits to encode the gate U, also the number of qubits in the system register</span>
    N <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> L <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># The total number of qubits in this algorithm</span>
    <span class="token comment"># The number of ancilla qubits used in the quantum phase estimation algorithm (QPE), also the number of qubits in</span>
    <span class="token comment"># the ancilla register</span>
    t <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> L <span class="token operator">+</span> <span class="token number">1</span>

    <span class="token comment"># Create a register, the first t qubits of which form the ancilla register, and the others form the system register.</span>
    q <span class="token operator">=</span> env<span class="token punctuation">.</span>Q<span class="token punctuation">.</span>createList<span class="token punctuation">(</span>N<span class="token punctuation">)</span>

    X<span class="token punctuation">(</span>q<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># We prepare the state |1&gt; in the system register, and will operate QPE</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>
        H<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># The first step in QPE, we prepare an average superposition state,</span>

    <span class="token comment"># The following is the transfer step in QPE, we will operate several C(U^(2^j)) gates</span>

    <span class="token comment"># The following is a decomposition of the gate C(U), the ctrlling qubit is the last qubit in the system register</span>
    CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> L<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> L<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> L<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> L<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> L<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    s <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> L <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment"># For the other C(U^(2^j)) gates, where q[s] is just the ctrlling qubit</span>
    <span class="token keyword">while</span> s <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> s <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token comment"># The decomposition of C(U^2) under this condition</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># The decomposition of C(U^4) under this condition</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CSWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        s <span class="token operator">-=</span> <span class="token number">1</span>  <span class="token comment"># Move the pointer to a higher ancilla qubit</span>

    <span class="token comment"># We need to operate an inverse Quantum Fourier Transform (QFT) on the ancilla register in the last step of QPE</span>
    <span class="token comment"># The SWAP step in inverse QFT</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>t <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        SWAP<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># The ctrl-rotation step in inverse QFT</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        H<span class="token punctuation">(</span>q<span class="token punctuation">[</span>t <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            CU<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>pi <span class="token operator">/</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>t <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>t <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    H<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># We have completed the inverse QFT and also QPE, and will measure the quantum state we have obtained</span>
    MeasureZ<span class="token punctuation">(</span>q<span class="token punctuation">[</span><span class="token punctuation">:</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">range</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># Only the ancilla register (i.e. the first t qubits) need to be measured</span>
    env<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">,</span> downloadResult<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    func_order_finding_2_mod_63<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Call the quantum algorithm for <span class="mathjax-exps">$8192$</span> times, omit those results of <span class="mathjax-exps">$5\%$</span> total frequency, and we process the remainder data as following, where <code>&quot;4096&quot;: 1419</code> indicates that there are <span class="mathjax-exps">$1419$</span> shots of <span class="mathjax-exps">$|4096\rangle$</span> in quantum measurement:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token punctuation">{</span>
    <span class="token string">&quot;4096&quot;</span><span class="token punctuation">:</span> <span class="token number">1419</span><span class="token punctuation">,</span>
    <span class="token string">&quot;0&quot;</span><span class="token punctuation">:</span> <span class="token number">1287</span><span class="token punctuation">,</span>
    <span class="token string">&quot;5461&quot;</span><span class="token punctuation">:</span> <span class="token number">955</span><span class="token punctuation">,</span>
    <span class="token string">&quot;2731&quot;</span><span class="token punctuation">:</span> <span class="token number">955</span><span class="token punctuation">,</span>
    <span class="token string">&quot;1365&quot;</span><span class="token punctuation">:</span> <span class="token number">940</span><span class="token punctuation">,</span>
    <span class="token string">&quot;6827&quot;</span><span class="token punctuation">:</span> <span class="token number">896</span><span class="token punctuation">,</span>
    <span class="token string">&quot;6826&quot;</span><span class="token punctuation">:</span> <span class="token number">252</span><span class="token punctuation">,</span>
    <span class="token string">&quot;1366&quot;</span><span class="token punctuation">:</span> <span class="token number">250</span><span class="token punctuation">,</span>
    <span class="token string">&quot;2730&quot;</span><span class="token punctuation">:</span> <span class="token number">246</span><span class="token punctuation">,</span>
    <span class="token string">&quot;5462&quot;</span><span class="token punctuation">:</span> <span class="token number">219</span><span class="token punctuation">,</span>
    <span class="token string">&quot;2732&quot;</span><span class="token punctuation">:</span> <span class="token number">56</span><span class="token punctuation">,</span>
    <span class="token string">&quot;5460&quot;</span><span class="token punctuation">:</span> <span class="token number">53</span><span class="token punctuation">,</span>
    <span class="token string">&quot;6828&quot;</span><span class="token punctuation">:</span> <span class="token number">52</span><span class="token punctuation">,</span>
    <span class="token string">&quot;1364&quot;</span><span class="token punctuation">:</span> <span class="token number">49</span><span class="token punctuation">,</span>
    <span class="token string">&quot;2729&quot;</span><span class="token punctuation">:</span> <span class="token number">47</span><span class="token punctuation">,</span>
    <span class="token string">&quot;1367&quot;</span><span class="token punctuation">:</span> <span class="token number">41</span><span class="token punctuation">,</span>
    <span class="token string">&quot;5463&quot;</span><span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">,</span>
    <span class="token string">&quot;6825&quot;</span><span class="token punctuation">:</span> <span class="token number">34</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span> 
</pre><p>Call the continued fraction expansion algorithm and compute all convergent, and we obtain:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">1419</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">1287</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5461</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">955</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2731</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">955</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">682</span><span class="token operator">/</span><span class="token number">4093</span><span class="token punctuation">,</span> <span class="token number">1365</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">940</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3411</span><span class="token operator">/</span><span class="token number">4093</span><span class="token punctuation">,</span> <span class="token number">6827</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">896</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1704</span><span class="token operator">/</span><span class="token number">2045</span><span class="token punctuation">,</span> <span class="token number">3413</span><span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">252</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">341</span><span class="token operator">/</span><span class="token number">2045</span><span class="token punctuation">,</span> <span class="token number">683</span><span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">250</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1365</span><span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">246</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2731</span><span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">219</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">683</span><span class="token operator">/</span><span class="token number">2048</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">56</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1365</span><span class="token operator">/</span><span class="token number">2048</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">53</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">851</span><span class="token operator">/</span><span class="token number">1021</span><span class="token punctuation">,</span> <span class="token number">1707</span><span class="token operator">/</span><span class="token number">2048</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">52</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token operator">/</span><span class="token number">1021</span><span class="token punctuation">,</span> <span class="token number">341</span><span class="token operator">/</span><span class="token number">2048</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">49</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">545</span><span class="token operator">/</span><span class="token number">1636</span><span class="token punctuation">,</span> <span class="token number">546</span><span class="token operator">/</span><span class="token number">1639</span><span class="token punctuation">,</span> <span class="token number">2729</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">47</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">136</span><span class="token operator">/</span><span class="token number">815</span><span class="token punctuation">,</span> <span class="token number">137</span><span class="token operator">/</span><span class="token number">821</span><span class="token punctuation">,</span> <span class="token number">410</span><span class="token operator">/</span><span class="token number">2457</span><span class="token punctuation">,</span> <span class="token number">1367</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">41</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1091</span><span class="token operator">/</span><span class="token number">1636</span><span class="token punctuation">,</span> <span class="token number">1093</span><span class="token operator">/</span><span class="token number">1639</span><span class="token punctuation">,</span> <span class="token number">5463</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">679</span><span class="token operator">/</span><span class="token number">815</span><span class="token punctuation">,</span> <span class="token number">684</span><span class="token operator">/</span><span class="token number">821</span><span class="token punctuation">,</span> <span class="token number">2047</span><span class="token operator">/</span><span class="token number">2457</span><span class="token punctuation">,</span> <span class="token number">6825</span><span class="token operator">/</span><span class="token number">8192</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token number">34</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</pre><p>The maximal denominators less than <span class="mathjax-exps">$N=63$</span> in each line is concerned (here is only <span class="mathjax-exps">$1,2,3,6$</span>). The frequency of denominator <span class="mathjax-exps">$2$</span>, <span class="mathjax-exps">$3$</span> and <span class="mathjax-exps">$6$</span> are <span class="mathjax-exps">$1419$</span>, <span class="mathjax-exps">$2567$</span> and <span class="mathjax-exps">$2514$</span>, respectively. Considering <span class="mathjax-exps">$\rm{ord}(2,63)=6$</span>, we have probability about <span class="mathjax-exps">$2514/8192 \approx 30.7\%$</span> to obtain <span class="mathjax-exps">${\rm ord}(2,15)=4$</span> correctly in each call of quantum phase estimation algorithm, and</p>
<p></p><div class="mathjax-exps">$$1-\left(1-\frac{2514}{8192}\right)^2+2 * \frac{1419}{8192} * \frac{2567}{8192}\approx 62.8\%\tag{16}$$</div><p></p>
<p>in each two calls, where the last adder indicates that one of the two denominators is <span class="mathjax-exps">$2$</span> and the other is <span class="mathjax-exps">$3$</span>. Since <span class="mathjax-exps">$2^{6/2} = 8\not\equiv -1\pmod{63}$</span>, we have <span class="mathjax-exps">$63|(8-1)(8+1)$</span> induces a factorization of <span class="mathjax-exps">$63$</span>:</p>
<p></p><div class="mathjax-exps">$$63=\textrm{gcd}(63,8-1)\times\textrm{gcd}(63,8+1)=7\times9.\tag{17}$$</div><p></p>
<p>Even though we do not use <span class="mathjax-exps">$U^{2^j}=I$</span> in this example,</p>
<p></p><div class="mathjax-exps">$$U^{2^3}=U^2\tag{18}$$</div><p></p>
<p>implies <span class="mathjax-exps">$U^{2^3-2}=I$</span> and <span class="mathjax-exps">$\rm{ord}(2,63)\,|\,(2^3-2)=6$</span>, which is also rejecting what is near at hand and seeking what is far away.</p>
<h2 class="mume-header" id="implements-of-gate-cu_an">Implements of Gate <span class="mathjax-exps">$C(U_{a,N})$</span></h2>

<p>To achieve the general implement of Shor&apos;s algorithm, we should find a general algorithm to decompose the quantum gate <span class="mathjax-exps">$C(U_{a,N})$</span>. In the last section, we introduce algebraic method to decompose gate <span class="mathjax-exps">$C(U_{a,N})$</span> into several <span class="mathjax-exps">$\operatorname{CSWAP}$</span> gates, and simplify gates <span class="mathjax-exps">$C(U_{a,N}^{2^j})$</span>. However, it doesn&apos;t make sense logically, not only the procedure of decomposition but also the omissions of gates equal to <span class="mathjax-exps">$I$</span>, which refer to or implies the fact that the factorization of <span class="mathjax-exps">$N$</span> has been known. More general algorithms on implementing gates <span class="mathjax-exps">$C(U_{a,N})$</span> refer to <span class="mathjax-exps">$[6,7]$</span>.</p>
<p>Besides these complicated method for reducing the number of ancilla qubits, we can implement the gate <span class="mathjax-exps">$C(U_{a,N})$</span> by <strong>Reversible Calculation</strong>.</p>
<h3 class="mume-header" id="reversible-calculation">Reversible Calculation</h3>

<h4 class="mume-header" id="from-classical-reversible-calculation-on">From (Classical) Reversible Calculation on</h4>

<p>What&apos;s the classical reversible calculation? It is known to us that classical computers are based on binary numbers and logic gates, and there are three elementary logic gates <span class="mathjax-exps">$\mathtt{AND}$</span> gate <span class="mathjax-exps">$\wedge$</span>, <span class="mathjax-exps">$\mathtt{OR}$</span> gate <span class="mathjax-exps">$\vee$</span> and <span class="mathjax-exps">$\mathtt{NOT}$</span> gate <span class="mathjax-exps">$\neg$</span>. It is clear that both <span class="mathjax-exps">$\mathtt{AND}$</span> gate and <span class="mathjax-exps">$\mathtt{OR}$</span> gate have two inputs and one output:</p>
<p></p><div class="mathjax-exps">$$\forall a,b\in\{0,1\},\ a\wedge b=ab,\ a\vee b=\neg(\neg a\wedge\neg b)=1-(1-a)(1-b),\ \neg a=1-a.\tag{19}$$</div><p></p>
<p>We call these calculation where we cannot recover the inputs from outputs <strong>irreversible calculation</strong>, and <strong>reversible calculation</strong> otherwise. It is clear to see that for a logical operator in reversible calculation, the number of output bits should be equal to that of input bits, such as the <span class="mathjax-exps">$\mathtt{NOT}$</span> gate is reversible calculation.</p>
<p>It can be predicted that if we maintain the input unchanged, and record the output on ancilla register, we will implement any function in reversible calculation, such as:</p>
<p></p><div class="mathjax-exps">$$(a,b,c)\rightarrow(a,b,c\oplus f(a,b)),\tag{20}$$</div><p></p>
<p>where <span class="mathjax-exps">$f(a,b)$</span> is an arbitrary function <span class="mathjax-exps">$\{0,1\}^2\rightarrow\{0,1\}$</span>, and <span class="mathjax-exps">$x\oplus y:=x+y\text{ mod }2$</span> is the result of <span class="mathjax-exps">$\mathtt{XOR}$</span> operator on <span class="mathjax-exps">$x$</span> and <span class="mathjax-exps">$y$</span>.</p>
<p>Finally, by introducing ancilla qubits, one can use quantum gates <span class="mathjax-exps">$X$</span>, <span class="mathjax-exps">$C(X)$</span> and <span class="mathjax-exps">$C^2(X)$</span> to simulate any reversible calculation in quantum computing, where:</p>
<p></p><div class="mathjax-exps">$$\begin{align*} X|a\rangle=&amp;\ |\neg a\rangle,\\ C^2(X)|a\rangle|b\rangle|0\rangle =&amp;\ |a\rangle|b\rangle|a\wedge b\rangle,\\ C(X)|a\rangle|0\rangle =&amp;\ |a\rangle|a\rangle=:\operatorname{FANOUT}|a\rangle. \end{align*}\tag{21}$$</div><p></p>
<p>Here <span class="mathjax-exps">$\operatorname{FANOUT}$</span> will make two copies of a classical bit, which can be simulated for the computational basis in quantum computing. According to the decomposition of <span class="mathjax-exps">$\mathtt{OR}$</span>, we have the quantum version for it:</p>
<p></p><div class="mathjax-exps">$$(X\otimes X\otimes X)\cdot C^2(X)\cdot(X\otimes X\otimes I)|a\rangle|b\rangle|0\rangle =\ |a\rangle|b\rangle|a\vee b\rangle.\tag{22}$$</div><p></p>
<p><img src="figures/vee.png" alt="Quantum  gate"></p>
<h4 class="mume-header" id="go-back-to-gates-u_an">Go Back to Gates <span class="mathjax-exps">$U_{a,N}$</span></h4>

<p>Recall the definition of</p>
<p></p><div class="mathjax-exps">$$U_{a,N}=\sum_{x=0}^{N-1}|{ax\ \textrm{mod } {N}}\rangle\langle{x}|+\sum_{x=N}^{2^L-1}|{x}\rangle\langle{x}|.\tag{23}$$</div><p></p>
<p>Given an input <span class="mathjax-exps">$x\in\{0,1,\cdots,2^L-1\}$</span>, we can always determine whether <span class="mathjax-exps">$x&lt; N$</span> classically, and compute <span class="mathjax-exps">$ax\textrm{ mod } N$</span> if <span class="mathjax-exps">$x&lt; N$</span>. The underlying implement of these determinations and computations must come down to logical gates, i.e. <span class="mathjax-exps">$\mathtt{AND}$</span>, <span class="mathjax-exps">$\mathtt{OR}$</span> and <span class="mathjax-exps">$\mathtt{NOT}$</span> gates. Thus these could be implemented quantumly. Say we finally obtain a quantum circuit <span class="mathjax-exps">$\operatorname{C}$</span> consist of several <span class="mathjax-exps">$X$</span>, <span class="mathjax-exps">$C(X)$</span> and <span class="mathjax-exps">$C^2(X)$</span> gates, which implements</p>
<p></p><div class="mathjax-exps">$$\operatorname{C}|x\rangle|0\rangle^{\otimes L}|0\rangle^{\otimes t}=|x\rangle(U_{a,N}|x\rangle)|0\rangle^{\otimes t},\tag{24}$$</div><p></p>
<p>where <span class="mathjax-exps">$t+L$</span> is the number of ancilla qubits introduced in the whole quantum circuit. According to the property of reversible computation, the number of quantum gates in the above quantum circuit and <span class="mathjax-exps">$t$</span> must be less than twice the number of logical gates in classical computing, which ensures effective implement of the quantum circuit <span class="mathjax-exps">$\operatorname{C}$</span>.</p>
<p><span class="mathjax-exps">$(24)$</span> is different from our purpose <span class="mathjax-exps">$|x\rangle\rightarrow U_{a,N}|x\rangle$</span>. By the way, we may use quantum gate <span class="mathjax-exps">$\operatorname{SWAP}$</span> to swap two registers, and implement a quantum gate <span class="mathjax-exps">$U_{a^{-1},N}^\dagger$</span> analogously to erase the information <span class="mathjax-exps">$|x\rangle$</span>:</p>
<p></p><div class="mathjax-exps">$$|x\rangle(U_{a,N}|x\rangle)|0\rangle^{\otimes t}\xrightarrow{\operatorname{SWAP}} (U_{a,N}|x\rangle)|x\rangle|0\rangle^{\otimes t}\xrightarrow{\operatorname{\hat C^\dagger}} (U_{a,N}|x\rangle)|0\rangle|0\rangle^{\otimes t},\tag{25}$$</div><p></p>
<p>where <span class="mathjax-exps">$\hat{\operatorname C}^\dagger$</span> is the inverse circuit for <span class="mathjax-exps">$\hat{\operatorname C}$</span>:</p>
<p></p><div class="mathjax-exps">$$(U_{a,N}|x\rangle)|0\rangle|0\rangle^{\otimes t} \xrightarrow{\operatorname{\hat C}} (U_{a,N}|x\rangle)(U_{a^{-1},N}U_{a,N}|x\rangle)|0\rangle^{\otimes t}=(U_{a,N}|x\rangle)|x\rangle|0\rangle^{\otimes t}.\tag{26}$$</div><p></p>
<p><strong>Example 8.</strong> We will deduct this procedure by an example <span class="mathjax-exps">$U_{2,3}$</span>:</p>
<p><img src="figures/2xmod3.png" alt></p>
<p><span class="mathjax-exps">$3$</span> zeroed qubits are introduced here. The first of them is used as a comparator storing whether <span class="mathjax-exps">$x &lt; 3$</span>, and will perform a controlling qubit to distinguish two cases. The other two zeroed qubits forms an ancilla register. We implement a map <span class="mathjax-exps">$|x\rangle|0\rangle\rightarrow|x\rangle|2x\text{ mod }3\rangle$</span> with the comparator as a controlling qubit. Then swap two registers to move <span class="mathjax-exps">$|2x\text{ mod }3\rangle$</span> into the system register also with the comparator as a controlling qubit. Then we may use <span class="mathjax-exps">$|2x\text{ mod }3\rangle$</span> to erase the information <span class="mathjax-exps">$|x\rangle$</span> in the ancilla register and obtain <span class="mathjax-exps">$|2x\text{ mod }3\rangle|0\rangle$</span>, because <span class="mathjax-exps">$2(2x\text{ mod 3})\text{ mod 3} = x$</span>. Finally, we erase the information in the comparator to implement a <span class="mathjax-exps">$U_{2,3}$</span> gate. The detailed evolution procedure of the five qubits are as follows:</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} |x\rangle|0\rangle|0\rangle\rightarrow \begin{cases} |x\rangle|1\rangle|0\rangle\rightarrow|x\rangle|1\rangle|2x\text{ mod }3\rangle\rightarrow|2x\text{ mod }3\rangle|1\rangle|x\rangle\rightarrow|2x\text{ mod }3\rangle|1\rangle|0\rangle\rightarrow|2x\text{ mod }3\rangle|0\rangle|0\rangle,&amp;x&lt;3;\\ |x\rangle|0\rangle|0\rangle\rightarrow|x\rangle|0\rangle|0\rangle\rightarrow|x\rangle|0\rangle|0\rangle\rightarrow|x\rangle|0\rangle|0\rangle\rightarrow|x\rangle|0\rangle|0\rangle,&amp;x=3. \end{cases} \end{eqnarray}\tag{27}$$</div><p></p>
<p>Of course, the computation for <span class="mathjax-exps">$2x\text{ mod }3$</span> is simplified greatly. For general cases, we may need more ancilla qubits to store carries and intermediate results of multiplication.</p>
<h3 class="mume-header" id="implements-of-general-cu_an-gates">Implements of General <span class="mathjax-exps">$C(U_{a,N})$</span> Gates</h3>

<p>In the quantum order-finding algorithm, the oracles are unitary matrices of form</p>
<p></p><div class="mathjax-exps">$$U_{a,N}=\sum_{x=0}^{N-1}|{ax\ \textrm{mod } {N}}\rangle\langle{x}|+\sum_{x=N}^{2^L-1}|{x}\rangle\langle{x}|.\tag{6}$$</div><p></p>
<p>Also some powers</p>
<p></p><div class="mathjax-exps">$$U_{a,N}^{2^k}=U_{a^{2^k}\text{ mod }N,N},$$</div><p></p>
<p>of <span class="mathjax-exps">$U_{a,N}$</span> are required, who have the same form <span class="mathjax-exps">$U_{\tilde a,N}$</span>. Thus it is a general quantum circuit implementing <span class="mathjax-exps">$U_{\tilde a,N}$</span> effectively that we need.</p>
<p>Hence, we refer to the algorithm in</p>
<p>[7] Beauregard, Stephane. &quot;Circuit for Shor&apos;s algorithm using 2n+3 qubits.&quot; Quantum Information &amp; Computation 3.2 (2003): 175-185.</p>
<p>to give the implement code for quantum gate <span class="mathjax-exps">$C(U_{a,N})$</span>. Similar to the procedure in example 8, here we also adopt the route</p>
<p></p><div class="mathjax-exps">$$|x\rangle|0\rangle^{\otimes L}|0\rangle^{\otimes t}\rightarrow|x\rangle(U_{a,N}|x\rangle)|0\rangle^{\otimes t}\xrightarrow{\operatorname{SWAP}} (U_{a,N}|x\rangle)|x\rangle|0\rangle^{\otimes t}\rightarrow (U_{a,N}|x\rangle)|0\rangle^{\otimes L}|0\rangle^{\otimes t}.\tag{28}$$</div><p></p>
<p>More detailed, to implement the quantum gate <span class="mathjax-exps">$U_{a,N}$</span>, we need to implement the following quantum gates and their controlling version (<span class="mathjax-exps">$C(U):=|0\rangle\langle0|\otimes I_*+|1\rangle\langle1|\otimes U$</span>) in order:</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} \Phi_{L,+a}&amp;:=&amp;\sum_{j=0}^{2^L-1}\Phi_{L}|j+a\text{ mod }2^L\rangle\langle j|\Phi_{L}^\dagger,\tag{29}\\ \Phi_{L,+a,\text{mod }N}&amp;:=&amp;\Phi_{L}\left(\sum_{j=0}^{N-1}|j+a\text{ mod }N\rangle\langle j|+\sum_{j=N}^{2^L-1}|j\rangle\langle j|\right)\Phi_{L}^\dagger,\tag{30}\\ U_{L,+a\cdot\text{ mod }N}&amp;:=&amp;\sum_{f=0}^{2^L-1}|f\rangle\langle f|\otimes\left(\sum_{y=0}^{N-1}|(y+af)\text{ mod }N\rangle\langle y|+\sum_{y=N}^{2^L-1}|y\rangle\langle y|\right),\tag{31} \end{eqnarray}$$</div><p></p>
<p>where <span class="mathjax-exps">$N&lt;2^L$</span>, <span class="mathjax-exps">$\Phi_L$</span> is the quantum Fourier transform <span class="mathjax-exps">$\operatorname{QFT}_ L$</span> without the <span class="mathjax-exps">$\operatorname{SWAP}$</span> step. Here we can understand those gates roughly: <span class="mathjax-exps">$\Phi_{L,+a}$</span> implements the operation <span class="mathjax-exps">$+a$</span> modulo <span class="mathjax-exps">$2^L$</span>; <span class="mathjax-exps">$\Phi_{L,+a,\text{mod }N}$</span> implements the operation <span class="mathjax-exps">$+a$</span> modulo <span class="mathjax-exps">$N$</span>; <span class="mathjax-exps">$U_{L,+a\cdot\text{ mod }N}$</span> implements the operation <span class="mathjax-exps">$\times a$</span> modulo <span class="mathjax-exps">$N$</span>, which is the first step in <span class="mathjax-exps">$(28)$</span>.</p>
<h4 class="mume-header" id="implements-of-~phi_la">Implements of <span class="mathjax-exps">$~\Phi$</span><span class="mathjax-exps">$_{L,+a}$</span></h4>

<p>Considering</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} \operatorname{QFT}_{L}|j\rangle&amp;=&amp;\bigotimes_{k=0}^{L-1}\frac{|0\rangle+e^{2\pi ij*2^{-k-1}}|1\rangle}{2},\tag{32}\\ \left(\bigotimes_{k=0}^{L-1}U_1(2\pi a*2^{-k-1})\right)\cdot \operatorname{QFT}_{L}|j\rangle&amp;=&amp;\bigotimes_{k=0}^{L-1}\left(U_1(2\pi a*2^{-k-1})\cdot\frac{|0\rangle+e^{2\pi ij*2^{-k-1}}|1\rangle}{2}\right)\\ &amp;=&amp;\bigotimes_{i=0}^{L-1}\frac{|0\rangle+e^{2\pi i(j+a)*2^{-k-1}}|1\rangle}{2}\tag{33}\\ &amp;=&amp;\operatorname{QFT}_{L}|j+a\text{ mod }2^L\rangle, \end{eqnarray}$$</div><p></p>
<p>we have</p>
<p></p><div class="mathjax-exps">$$\bigotimes_{k=0}^{L-1}U_1(2\pi a*2^{-k-1})=\sum_{j=0}^{2^L-1}\operatorname{QFT}_{L}|j+a\text{ mod }2^L\rangle\langle j|\operatorname{QFT}_{L}^\dagger.\tag{34}$$</div><p></p>
<p>Since there is a sequence of <span class="mathjax-exps">$\operatorname{SWAP}$</span> gates in the implement of <span class="mathjax-exps">$\operatorname{QFT}$</span> which are unnecessary for the implement in <span class="mathjax-exps">$(34)$</span>, we redefine <span class="mathjax-exps">$\Phi_L$</span> as <span class="mathjax-exps">$\operatorname{QFT}_{L}$</span> without the <span class="mathjax-exps">$\operatorname{SWAP}$</span> step. Thus we have</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} \Phi_{L}|j\rangle&amp;=&amp;\bigotimes_{k=0}^{L-1}\frac{|0\rangle+e^{2\pi ij*2^{k-L}}|1\rangle}{2},\tag{35}\\ \left(\bigotimes_{k=0}^{L-1}U_1(2\pi a*2^{k-L})\right)\cdot \Phi_{L}|j\rangle&amp;=&amp;\Phi_{L}|j+a\text{ mod }2^L\rangle,\tag{36}\\ \bigotimes_{k=0}^{L-1}U_1(2\pi a*2^{k-L})&amp;=&amp;\sum_{j=0}^{2^L-1}\Phi_{L}|j+a\text{ mod }2^L\rangle\langle j|\Phi_{L}^\dagger,\tag{37} \end{eqnarray}$$</div><p></p>
<p>The following is the code for <span class="mathjax-exps">$\Phi_L$</span>, where it is noted that <code>QFT</code> refers to <span class="mathjax-exps">$\operatorname{QFT}$</span> <strong>WITHOUT</strong> <span class="mathjax-exps">$\operatorname{SWAP}$</span> step in all codes in this subsection, which will be omitted after:</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_qft_without_swap</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    Quantum Fourier Transform without the swap step, |s&gt; -&gt; QFT|s&gt;
    :param reg_system: |s&gt;
    :return:
    &quot;&quot;&quot;</span>
    number_qubit <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    <span class="token keyword">for</span> idx1_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> number_qubit <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># The outer loop</span>
        H<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span>idx1_qubit<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># Operate a H gate on the idx1-th qubit</span>
        <span class="token keyword">for</span> idx2_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> number_qubit <span class="token operator">-</span> idx1_qubit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># The inner loop</span>
            <span class="token comment"># where we will operate a CU1 gate in each loop</span>
            idx3_qubit <span class="token operator">=</span> idx1_qubit <span class="token operator">+</span> idx2_qubit <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment"># idx3 is the idx for the ctrlling qubit</span>
            <span class="token comment"># idx1 is the ctrlled qubit and idx2 is related to the rotation angle</span>
            CU<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> pi <span class="token operator">/</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> idx2_qubit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span>idx3_qubit<span class="token punctuation">]</span><span class="token punctuation">,</span> reg_system<span class="token punctuation">[</span>idx1_qubit<span class="token punctuation">]</span><span class="token punctuation">)</span>
    H<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span>number_qubit <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># Do not forget there is a H gate operating on the last qubit</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Then we have the decomposition and code implement for <span class="mathjax-exps">$\Phi_{L,+a}$</span>:</p>
<p><img src="figures/Phi_Add_a.png" alt></p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_qftadd</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> int_adder<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    a circuit implement the addition under the Fourier bases
    :param reg_system: QFT|s&gt;, we write the state as a image of the Fourier transform
    :param int_adder: a
    :return: a circuit which implement the map: QFT|s&gt; -&gt; QFT|s+a&gt;
    &quot;&quot;&quot;</span>
    <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># For each qubit in the reg_s, we operate a U1 gate on it</span>
        U<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> pi <span class="token operator">*</span> <span class="token punctuation">(</span>int_adder <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token punctuation">(</span>idx_qubit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token punctuation">(</span>idx_qubit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
            reg_system<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> idx_qubit<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><h4 class="mume-header" id="implements-of-c2phi_latextmod-n">Implements of <span class="mathjax-exps">$C^2(\Phi_{L,+a,\text{mod }N})$</span></h4>

<p>Here we present the implement of <span class="mathjax-exps">$C^2(\Phi_{L,+a,\text{mod }N})$</span> directly. We can obtain the implements of <span class="mathjax-exps">$C(\Phi_{L,+a,\text{mod }N})$</span> and <span class="mathjax-exps">$\Phi_{L,+a,\text{mod }N}$</span> easily by removing the controlling qubits.</p>
<p><img src="figures/Phi_Add_Mod.png" alt></p>
<p>Here <span class="mathjax-exps">$|c_1\rangle$</span> and <span class="mathjax-exps">$|c_2\rangle$</span> are two controlling qubits. The last line <span class="mathjax-exps">$|0\rangle$</span> is called a <strong>zeroed qubit</strong>, where as long as input state is <span class="mathjax-exps">$|0\rangle$</span>, the output state must also be <span class="mathjax-exps">$|0\rangle$</span>. It needs more explanation here that only when</p>
<p></p><div class="mathjax-exps">$$L\ge\lceil \log_2 N\rceil+1,\tag{38}$$</div><p></p>
<p>and</p>
<p></p><div class="mathjax-exps">$$s=0,1,\cdots,N-1,\tag{39}$$</div><p></p>
<p>the above quantum circuit <span class="mathjax-exps">$\mathcal C_{C^2(\Phi_{L,+a,\text{mod }N})}$</span> implements the mapping:</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} \mathcal C_{C^2(\Phi_{L,+a,\text{mod }N})}|c_1\rangle|c_2\rangle\left(\Phi_L|s\rangle\right)|0\rangle &amp;=&amp;\left(C^2(\Phi_{L,+a,\text{mod }N})|c_1\rangle|c_2\rangle\left(\Phi_L|s\rangle\right)\right)|0\rangle\\ &amp;=&amp;|c_1\rangle|c_2\rangle\left(\Phi_L|s+c_1c_2a\text{ mod }N\rangle\right)|0\rangle. \end{eqnarray}\tag{40}$$</div><p></p>
<p>If the conditions are not satisfied, there may occur some leakage or some zeroed qubits may not reset to <span class="mathjax-exps">$|0\rangle$</span> and be entangled with other qubits. Meanwhile the evolution may not be as expected.</p>
<p>Additionally, quantum computing allows superposition. When two states are legal, their superposition states will also be legal. Thus the state in the third and fourth line may also be</p>
<p></p><div class="mathjax-exps">$$\Phi_L\sum_{s=0}^{N-1}p_s|s\rangle,\tag{41}$$</div><p></p>
<p>where</p>
<p></p><div class="mathjax-exps">$$\sum_{s=0}^{N-1}|p_s|^2=1.\tag{42}$$</div><p></p>
<p>For similar cases, we will not repeat it later and still say <span class="mathjax-exps">$s=0,\cdots,N-1$</span> simply.</p>
<p>In the following code implement, we denote the first and second line as <code>reg_ctrlling</code>,the third and fourth line as <code>reg_system</code> with the third line as <code>reg_system[0]</code>, the last line as <code>qubit_zeroed</code>, integers <span class="mathjax-exps">$a$</span> and <span class="mathjax-exps">$N$</span> as <code>int_adder</code> and <code>int_divisor</code>, respectively. Those functions named with the end <code>_inverse</code> denotes the inverse circuit of the corresponding function; those functions named with the head <code>func_ctrl</code> or <code>func_double_ctrl</code> denotes the control version or double control version of the corresponding function.</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_double_ctrl_qftaddmod</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_ctrlling<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> int_adder<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    CC-qftadd(int_adder)mod(int_divisor)
    |c_1&gt;|c_2&gt;QFT|s&gt; -&gt; &lt;0|c_1*c_2&gt;*|c_1&gt;|c_2&gt;QFT|s&gt; + &lt;1|c_1*c_2&gt;*|c_1&gt;|c_2&gt;QFT|s+a mod d&gt;
    the complement comes from the Figure 5 in arXiv quant-ph/0205095
    :param reg_system: QFT|s&gt; with s &lt; d
    :param reg_ctrlling: [|c_1&gt;,|c_2&gt;]
    :param qubit_zeroed: |0&gt;
    :param int_adder: a with a &lt; d
    :param int_divisor: d
    :return: |c_1&gt;|c_2&gt;QFT|s&gt;|0&gt; -&gt; &lt;0|c_1*c_2&gt;*|c_1&gt;|c_2&gt;QFT|s&gt;|0&gt; + &lt;1|c_1*c_2&gt;*|c_1&gt;|c_2&gt;QFT|s+a mod d&gt;|0&gt;
    &quot;&quot;&quot;</span>
    func_double_ctrl_qftadd<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_ctrlling<span class="token punctuation">,</span> int_adder<span class="token punctuation">)</span>
    func_qftadd_inverse<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
    func_qft_without_swap_inverse<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    CX<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">)</span>
    func_qft_without_swap<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    func_ctrl_qftadd<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
    func_double_ctrl_qftadd_inverse<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_ctrlling<span class="token punctuation">,</span> int_adder<span class="token punctuation">)</span>
    func_qft_without_swap_inverse<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    X<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CX<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">)</span>
    X<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    func_qft_without_swap<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    func_double_ctrl_qftadd<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_ctrlling<span class="token punctuation">,</span> int_adder<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Especially, the double control gate <span class="mathjax-exps">$C^2(U_1)$</span> is required in the double control version of some quantum subcircuits, whose implements are as follows:</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">CCU1</span><span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q2<span class="token punctuation">,</span> q3<span class="token punctuation">,</span> float_theta<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    a single-parameter three-qubit gate, which is the double-ctrl version for U1 gate,
    the matrix form of CCU1(theta) is the diagonal matrix {1,1,1,1,1,1,1,e^{i theta}}
    in fact we do not distinguish which qubit is the ctrlling or ctrlled qubit
    :param q1: a qubit
    :param q2: another qubit
    :param q3: a third qubit
    :param float_theta: the rotation angle
    :return: |q1&gt;|q2&gt;|q3&gt; -&gt; &lt;0|q1*q2*q3&gt;*|q1&gt;|q2&gt;|q3&gt; + e^{i theta}*&lt;1|q1*q2*q3&gt;*|q1&gt;|q2&gt;|q3&gt;
    &quot;&quot;&quot;</span>
    float_theta_half <span class="token operator">=</span> float_theta <span class="token operator">/</span> <span class="token number">2</span>
    CU<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> float_theta_half<span class="token punctuation">)</span><span class="token punctuation">(</span>q2<span class="token punctuation">,</span> q3<span class="token punctuation">)</span>
    CX<span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span>
    CU<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>float_theta_half<span class="token punctuation">)</span><span class="token punctuation">(</span>q2<span class="token punctuation">,</span> q3<span class="token punctuation">)</span>
    CX<span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span>
    CU<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> float_theta_half<span class="token punctuation">)</span><span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q3<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Afterword: Even though we say we want to implement quantum gates <span class="mathjax-exps">$\Phi_{+a,\text{mod }N}$</span>, in fact it is a projection <span class="mathjax-exps">$B$</span> of its matrix form what we need. When we have a quantum circuit <span class="mathjax-exps">$\mathcal C$</span> satisfying</p>
<p></p><div class="mathjax-exps">$$\mathcal C\cdot\Phi_{L}\sum_{j=0}^{N-1}|j\rangle\langle j|\Phi_{L}^\dagger=B:=\Phi_{L,+a,\text{mod }N}\cdot\Phi_{L}\sum_{j=0}^{N-1}|j\rangle\langle j|\Phi_{L}^\dagger,\tag{43}$$</div><p></p>
<p>we can regard <span class="mathjax-exps">$\mathcal C$</span> as an effectively implement of <span class="mathjax-exps">$B$</span>. We call this method block-encoding that encoding effective information <span class="mathjax-exps">$B$</span> into a quantum circuit <span class="mathjax-exps">$\mathcal C$</span> as a projection. Meanwhile, <span class="mathjax-exps">$\mathcal C$</span> has form:</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} \mathcal C&amp;:=&amp;\Phi_{L}\left(\sum_{j=0}^{N-1}|j+a\text{ mod }N\rangle\langle j|+\sum_{j=N}^{2^L-1}|\tilde j\rangle\langle j|\right)\Phi_{L}^\dagger,\tag{44}\\ \Phi_{L,+a,\text{mod }N}&amp;:=&amp;\Phi_{L}\left(\sum_{j=0}^{N-1}|j+a\text{ mod }N\rangle\langle j|+\sum_{j=N}^{2^L-1}|j\rangle\langle j|\right)\Phi_{L}^\dagger,\tag{45} \end{eqnarray}$$</div><p></p>
<p>where <span class="mathjax-exps">$\{|\tilde j\rangle\}$</span> should be an orthonormal bases of <span class="mathjax-exps">$\text{Span}\{|j\rangle\,|\,j=N,\cdots2^L-1\}$</span>. It is clear to see that <span class="mathjax-exps">$\Phi_{L,+a,\text{mod }N}$</span> is a special case of implements for <span class="mathjax-exps">$\mathcal C$</span>.</p>
<h4 class="mume-header" id="implements-of-u_lacdottext-mod-n">Implements of <span class="mathjax-exps">$U_{L,+a\cdot\text{ mod }N}$</span></h4>

<p>Recall the definition of <span class="mathjax-exps">$U_{L,+a\cdot\text{ mod }N}$</span> as follows:</p>
<p></p><div class="mathjax-exps">$$U_{L,+a\cdot\text{ mod }N}:=\sum_{f=0}^{2^L-1}|f\rangle\langle f|\otimes\left(\sum_{y=0}^{N-1}|(y+af)\text{ mod }N\rangle\langle y|+\sum_{y=N}^{2^L-1}|y\rangle\langle y|\right).\tag{46}$$</div><p></p>
<p>Expand <span class="mathjax-exps">$f$</span> as binary to <span class="mathjax-exps">$f=\sum_{j=0}^*2^jf_j$</span>, and we decompose the multiplication into additions:</p>
<p></p><div class="mathjax-exps">$$af=\sum_{j=0}^*2^jf_j\cdot a.\tag{47}$$</div><p></p>
<p>Furtherly, we have</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} &amp;&amp;s+af\text{ mod }N=\left(\sum_{j=0}^*2^jf_j\cdot a\right)\text{ mod }N\\ &amp;=&amp;s+_{\text{mod }N}(2^0a\text{ mod }N)f_0+_{\text{mod }N}(2^1a\text{ mod }N)f_1+_{\text{mod }N}\cdots+_{\text{mod }N} (2^*a\text{ mod }N)f_*, \end{eqnarray}\tag{48}$$</div><p></p>
<p>where <span class="mathjax-exps">$+_{\text{mod }N}$</span> denotes the sum modulo <span class="mathjax-exps">$N$</span>, which make sure that the output satisfies the input condition, i.e. outputs stay in the integer interval <span class="mathjax-exps">$\{0,1,\cdots,N-1\}$</span>.</p>
<p><img src="figures/U_Add_Prod_Mod.png" alt></p>
<p>It is checked that if <span class="mathjax-exps">$L\ge\lceil \log_2 N\rceil+1$</span> and <span class="mathjax-exps">$s=0,1,\cdots N-1$</span>, the above circuit satisfies</p>
<p></p><div class="mathjax-exps">$$\mathcal C_{U_{L,+a\cdot\text{ mod }N}}|c\rangle|f\rangle|s\rangle ={U_{L,+a\cdot\text{ mod }N}}|c\rangle|f\rangle|s\rangle =|c\rangle|f\rangle|s+caf\text{ mod }N\rangle.\tag{49}$$</div><p></p>
<p>It is worth noting that there&apos;re requirements for <span class="mathjax-exps">$|s\rangle$</span> but no for <span class="mathjax-exps">$|f\rangle$</span>. Finally we denote <span class="mathjax-exps">$|s\rangle$</span>,<span class="mathjax-exps">$|f\rangle$</span>,<span class="mathjax-exps">$|c\rangle$</span> as <code>reg_system</code>,<code>reg_factor_1</code>, <code>qubit_ctrlling</code>, and <span class="mathjax-exps">$a,N$</span> as <code>int_factor_2</code>,<code>int_divisor</code>, respectively, and introduce <code>qubit_zeroed</code> as the zeroed qubit needed in the implement of <span class="mathjax-exps">$\mathcal C_{C^2(\Phi_{L,+a,\text{mod }N})}$</span>. Then we have a code implement as following:</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_ctrl_addprodmod</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_factor_1<span class="token punctuation">,</span> qubit_ctrlling<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> int_factor_2<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    :param reg_system: |s&gt; with s &lt; d
    :param reg_factor_1: |f_1&gt;, a quantum state encoding the factor_1
    :param qubit_ctrlling: |c&gt;
    :param qubit_zeroed: |0&gt;
    :param int_factor_2: f_2, a classical data
    :param int_divisor: d
    :return: |c&gt;|f_1&gt;|s&gt; -&gt; &lt;0|c&gt;|c&gt;|f_1&gt;|s&gt; + &lt;1|c&gt;|c&gt;|f_1&gt;|s+ f_1*f_2 mod d&gt;
    the complement comes from the Figure 6 in arXiv quant-ph/0205095
    &quot;&quot;&quot;</span>
    func_qft_without_swap<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
    <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>reg_factor_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># For each qubit in reg_f_1, we will operate a CC-qftaddmod gate where</span>
        <span class="token comment"># regarding idx_qubit as one of the two ctrlling qubit</span>
        func_double_ctrl_qftaddmod<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> <span class="token punctuation">[</span>qubit_ctrlling<span class="token punctuation">,</span> reg_factor_1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> idx_qubit<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span>
                                   <span class="token punctuation">(</span>int_factor_2 <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> idx_qubit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> int_divisor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
    func_qft_without_swap_inverse<span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><h4 class="mume-header" id="implements-of-u_an">Implements of <span class="mathjax-exps">$U_{a,N}$</span></h4>

<p>Considering</p>
<p></p><div class="mathjax-exps">$$s-a^{-1}as\equiv 0\pmod N,\tag{50}$$</div><p></p>
<p>where <span class="mathjax-exps">$a^{-1}$</span> is the inverse of <span class="mathjax-exps">$a$</span> modulo <span class="mathjax-exps">$N$</span> (<span class="mathjax-exps">$a^{-1}a\equiv1\pmod N$</span>), which can be computed by extended Euclidean algorithm effectively, then the procedure in formula <span class="mathjax-exps">$(28)$</span> can be represented as</p>
<p></p><div class="mathjax-exps">$$\begin{eqnarray} |s\rangle|0\rangle \rightarrow U_{L,+a\cdot\text{ mod }N}|s\rangle|0\rangle =|s\rangle|as\rangle \stackrel{\operatorname{SWAP}}\longrightarrow|as\rangle|s\rangle \rightarrow U_{L,+a^{-1}\cdot\text{ mod }N}^\dagger|as\rangle|s\rangle =|as\rangle|0\rangle. \end{eqnarray}\tag{51}$$</div><p></p>
<p>We show the circuit decomposition of <span class="mathjax-exps">$C(U_{a,N})$</span> as following:</p>
<p><img src="figures/U_aN.png" alt></p>
<p>Here <span class="mathjax-exps">$f &lt; N$</span>, <span class="mathjax-exps">$|0\rangle$</span> is a sequence of zeroed qubits, and <span class="mathjax-exps">$\operatorname{SWAP}$</span> is a sequence of <span class="mathjax-exps">$\operatorname{SWAP}$</span> gates operating on corresponding qubits in two registers. It is noted that we need <span class="mathjax-exps">$\lceil\log_2 N\rceil$</span> qubits to encode the quantum state <span class="mathjax-exps">$|f\rangle$</span>, and <span class="mathjax-exps">$\lceil\log_2 N\rceil+1$</span> to <span class="mathjax-exps">$|0\rangle$</span>. Also noted that the <span class="mathjax-exps">$\operatorname{SWAP}$</span> gates align from low position of the two registers, and there&apos;s no <span class="mathjax-exps">$\operatorname{SWAP}$</span> gates operating on the highest position of <span class="mathjax-exps">$|0\rangle$</span>. A highest zeroed qubit is needed in the implement of <span class="mathjax-exps">$C^2(\Phi_{L,+a,\text{mod }N})$</span> (as a carry), so <span class="mathjax-exps">$|0\rangle$</span> has one qubit more than <span class="mathjax-exps">$|f\rangle$</span>.</p>
<p>Then we show the code implement. Here we denote <span class="mathjax-exps">$|f\rangle$</span>,<span class="mathjax-exps">$|0\rangle$</span>,<span class="mathjax-exps">$|c\rangle$</span> as <code>reg_system</code>,<code>reg_zeroed</code>, <code>qubit_ctrlling</code>, and <span class="mathjax-exps">$a,N$</span> as <code>int_factor</code>,<code>int_divisor</code>, respectively, and introduce <code>qubit_zeroed</code> as the zeroed qubit required in the implement of <span class="mathjax-exps">$\mathcal C_{C^2(\Phi_{L,+a,\text{mod }N})}$</span>.</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_ctrl_multmod</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_zeroed<span class="token punctuation">,</span> qubit_ctrlling<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    |c&gt;|s&gt; -&gt; &lt;0|c&gt;|c&gt;|s&gt;  + &lt;1|c&gt;|c&gt;|s * f mod d&gt;
    the complement comes from the Figure 7 in arXiv quant-ph/0205095
    :param reg_system: |s&gt;
    :param reg_zeroed: |0*&gt;, a register initialled into |0*&gt;
    :param qubit_ctrlling: |c&gt;
    :param qubit_zeroed: |0&gt;, a qubit at state |0&gt;
    :param int_factor: f
    :param int_divisor: d
    :return: |c&gt;|s&gt;|0*&gt;|0&gt; -&gt; &lt;0|c&gt;|c&gt;|s&gt;|0*&gt;|0&gt;  + &lt;1|c&gt;|c&gt;|s * f mod d&gt;|0*&gt;|0&gt;
    &quot;&quot;&quot;</span>
    func_ctrl_addprodmod<span class="token punctuation">(</span>reg_zeroed<span class="token punctuation">,</span> reg_system<span class="token punctuation">,</span> qubit_ctrlling<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
    <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>reg_system<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>reg_zeroed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># We CSWAP the corresponding qubit in those two reg</span>
        <span class="token comment"># from the end since maybe the two reg has different length</span>
        CSWAP<span class="token punctuation">(</span>qubit_ctrlling<span class="token punctuation">,</span> reg_system<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> idx_qubit<span class="token punctuation">]</span><span class="token punctuation">,</span> reg_zeroed<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> idx_qubit<span class="token punctuation">]</span><span class="token punctuation">)</span>
    func_ctrl_addprodmod_inverse<span class="token punctuation">(</span>reg_zeroed<span class="token punctuation">,</span> reg_system<span class="token punctuation">,</span> qubit_ctrlling<span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 int_divisor<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Here <span class="mathjax-exps">$a^{-1}\pmod N$</span> is computed by calling the function <code>pow</code> in python.</p>
<h4 class="mume-header" id="implements-of-quantum-order-finding-algorithm">Implements of Quantum Order-Finding Algorithm</h4>

<p>Denote <code>int_factor</code>,<code>int_divisor</code>,<code>int_shots</code>,<code>number_qubit_ancilla</code> as the base, the modulus, the shot number for each quantum circuit, the number of ancilla qubits in the quantum phase estimation algorithm, respectively. Then we have the code implement of quantum order-finding algorithm as follows:</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_quantum_order_finding</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_shots<span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    :param int_factor: f
    :param int_divisor: d
    :param int_shots: the shots number for each quantum circuit
    :param number_qubit_ancilla: the number of qubits for the estimating the phase
    :return: an estimation for the fraction r/ord(f,d)/2^t, where ord(f,d) is the order of f mod d, r is a random in
             {0,1,...,ord(f,d)-1}, and t = number_qubit_ancilla as following corresponding to the precision.
    &quot;&quot;&quot;</span>
    <span class="token comment"># Create the quantum environment</span>
    env <span class="token operator">=</span> QEnv<span class="token punctuation">(</span><span class="token punctuation">)</span>
    Define<span class="token punctuation">.</span>hubToken <span class="token operator">=</span> <span class="token string">&apos;&apos;</span>
    <span class="token comment"># Choose backend</span>
    env<span class="token punctuation">.</span>backend<span class="token punctuation">(</span>BackendName<span class="token punctuation">.</span>LocalBaiduSim2<span class="token punctuation">)</span>
    <span class="token comment"># env.backend(BackendName.CloudBaiduSim2Water)</span>

    <span class="token comment"># Decide the number of qubit which will be used to encode the eigenstate</span>
    number_qubit_system <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># Create the quantum register</span>
    <span class="token comment"># The ancilla qubit used for phase estimation</span>
    reg_ancilla <span class="token operator">=</span> <span class="token punctuation">[</span>env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>idx_qubit<span class="token punctuation">]</span> <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">)</span><span class="token punctuation">]</span>
    number_qubit_part2 <span class="token operator">=</span> number_qubit_ancilla <span class="token operator">+</span> number_qubit_system
    <span class="token comment"># The system register holding the eigenstate</span>
    reg_system <span class="token operator">=</span> <span class="token punctuation">[</span>env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>idx_qubit<span class="token punctuation">]</span> <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number_qubit_ancilla<span class="token punctuation">,</span> number_qubit_part2<span class="token punctuation">)</span><span class="token punctuation">]</span>
    number_qubit_part3 <span class="token operator">=</span> number_qubit_ancilla <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> number_qubit_system <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token comment"># The zeroed register used in the circuit of func_ctrl_multmod</span>
    reg_zeroed <span class="token operator">=</span> <span class="token punctuation">[</span>env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>idx_qubit<span class="token punctuation">]</span> <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number_qubit_part2<span class="token punctuation">,</span> number_qubit_part3<span class="token punctuation">)</span><span class="token punctuation">]</span>
    qubit_zeroed <span class="token operator">=</span> env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>number_qubit_part3<span class="token punctuation">]</span>  <span class="token comment"># The other zeroed qubit used in the circuit of func_ctrl_multmod</span>

    <span class="token comment"># Initialise the state |0...01&gt; as a superposition of concerned eigenstates</span>
    X<span class="token punctuation">(</span>reg_system<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># The following is the quantum phase estimation algorithm</span>
    <span class="token keyword">for</span> idx_qubit <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>reg_ancilla<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        H<span class="token punctuation">(</span>reg_ancilla<span class="token punctuation">[</span>idx_qubit<span class="token punctuation">]</span><span class="token punctuation">)</span>
        func_ctrl_multmod<span class="token punctuation">(</span>reg_system<span class="token punctuation">,</span> reg_zeroed<span class="token punctuation">,</span> reg_ancilla<span class="token punctuation">[</span>idx_qubit<span class="token punctuation">]</span><span class="token punctuation">,</span> qubit_zeroed<span class="token punctuation">,</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">**</span> idx_qubit<span class="token punctuation">,</span>
                                                                                            int_divisor<span class="token punctuation">)</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
    func_qft_without_swap_inverse<span class="token punctuation">(</span>reg_ancilla<span class="token punctuation">)</span>

    <span class="token comment"># We only measure the reg_ancilla, which gives the estimation of the phase</span>
    MeasureZ<span class="token punctuation">(</span>reg_ancilla<span class="token punctuation">,</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number_qubit_ancilla<span class="token punctuation">)</span><span class="token punctuation">)</span>

    env<span class="token punctuation">.</span>module<span class="token punctuation">(</span>CompositeGateModule<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> func_qof_data_processing<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">,</span> env<span class="token punctuation">.</span>commit<span class="token punctuation">(</span>
        int_shots<span class="token punctuation">,</span> fetchMeasure<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">&quot;counts&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>There&apos;re five parts in this code:</p>
<ol>
<li>set the quantum register;</li>
<li>initial the quantum state;</li>
<li>call the quantum circuit for quantum phase estimation algorithm;</li>
<li>measure the final quantum state;</li>
<li>call the function for data post processing.</li>
</ol>
<p>The following function is used for data post processing:</p>
<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_qof_data_processing</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">,</span> dict_task_result_counts<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    :param int_divisor: d
    :param number_qubit_ancilla: the number of qubits for the estimating the phase
    :param dict_task_result_counts: a dict storing the counts data in the task result
    :return: a dict {&quot;order&quot;:shots} storing the order and the shots, such as {&quot;2&quot;:5,&quot;4&quot;:7} means that 5 shots indicate
             the order may be 2 and 7 shots indicate the order may be 4.
    dict_task_result_counts of form {&quot;quantum_output&quot;:shots} is a quantum output from an estimation for the fraction
    r/ord(f,d)/2^t, where ord(f,d) is the order of f mod d, r is a random in {0,1,...,ord(f,d)-1}, and
    t = number_qubit_ancilla as following corresponding to the precision.
    For the case that the ancilla is enough we compute the maximal denominator, and for the case that the ancilla is not
    enough we compute all the possible denominators.
    &quot;&quot;&quot;</span>
    dict_order <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment"># The case that the number of ancilla is enough</span>
    <span class="token keyword">if</span> number_qubit_ancilla <span class="token operator">&gt;=</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> idx_key <span class="token keyword">in</span> dict_task_result_counts<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># We need to transform the key in dict_task</span>
            <span class="token keyword">if</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># Skip the measurement results with counts &lt;= 0</span>
                <span class="token keyword">continue</span>
            <span class="token comment"># From a numerator to the order by calling func_result_to_order</span>
            int_order_maybe <span class="token operator">=</span> func_result_to_order<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>idx_key<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
            str_int_order_maybe <span class="token operator">=</span> <span class="token string">&quot;{0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_order_maybe<span class="token punctuation">)</span>
            <span class="token keyword">if</span> str_int_order_maybe <span class="token keyword">not</span> <span class="token keyword">in</span> dict_order<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dict_order<span class="token punctuation">[</span>str_int_order_maybe<span class="token punctuation">]</span> <span class="token operator">=</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dict_order<span class="token punctuation">[</span>str_int_order_maybe<span class="token punctuation">]</span> <span class="token operator">+=</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># The case that the number of ancilla is not enough</span>
        <span class="token keyword">for</span> idx_key <span class="token keyword">in</span> dict_task_result_counts<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># We need to transform the key in dict_task</span>
            <span class="token comment"># from a numerator to the order by calling func_result_to_order</span>
            <span class="token keyword">if</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># Skip the measurement results with counts &lt;= 0</span>
                <span class="token keyword">continue</span>
            list_int_order_maybe <span class="token operator">=</span> func_result_to_order_list<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>idx_key<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
            <span class="token keyword">for</span> int_order_maybe <span class="token keyword">in</span> list_int_order_maybe<span class="token punctuation">:</span>
                str_int_order_maybe <span class="token operator">=</span> <span class="token string">&quot;{0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_order_maybe<span class="token punctuation">)</span>
                <span class="token keyword">if</span> str_int_order_maybe <span class="token keyword">not</span> <span class="token keyword">in</span> dict_order<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    dict_order<span class="token punctuation">[</span>str_int_order_maybe<span class="token punctuation">]</span> <span class="token operator">=</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    dict_order<span class="token punctuation">[</span>str_int_order_maybe<span class="token punctuation">]</span> <span class="token operator">+=</span> dict_task_result_counts<span class="token punctuation">[</span>idx_key<span class="token punctuation">]</span>
    <span class="token keyword">return</span> dict_order
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>whose input is the measurement result of the quantum circuit <code>dict_task_result_counts</code>, the number of ancilla qubits <code>number_qubit_ancilla</code> for computing the denominator of <span class="mathjax-exps">$k$</span> and the modulus <code>int_divisor</code> for bounding the order. Here <code>dict_task_result_counts</code> is a <code>dict</code> in python, the keys of whose items are quantum states as a <code>str</code> and values are corresponding measurement times. The output of this function is also a <code>dict</code>, the keys of whose items are &quot;orders&quot;, and values are also corresponding measurement times. We use &quot;orders&quot; here, because these &quot;order&quot; may be wrong, but are just results after data processing. There are two cases to distinguish whether the ancilla qubits introduced are enough. If the ancilla qubits are enough, we select the maximal denominator less than the modulus of each convergent as the returns of continued fraction expansion algorithm, corresponding to the function <code>func_result_to_order</code>; otherwise we list the denominators of all convergent as the returns, corresponding to the function <code>func_result_to_order_list</code>. Here <code>func_result_to_order</code> and <code>func_result_to_order_list</code> are classical computing, whose essence is just Euclidean algorithm, where we won&apos;t go into much detail.</p>
<p>Finally, we come back to</p>
<h4 class="mume-header" id="implements-of-shors-algorithm">Implements of Shor&apos;s Algorithm</h4>

<pre data-role="codeBlock" data-info="python{.line-numbers}" class="language-python line-numbers"><span class="token keyword">def</span> <span class="token function">func_Shor_algorithm</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> int_shots<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> int_factor<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    We want to factor the int int_divisor
    :param int_divisor: d, which we want to factor
    :param number_qubit_ancilla: the number of qubit which will be used for quantum phase estimation
    :param int_shots: the number of shots whose default value is 2; when int_shots &gt; 2 means we want to know the
                      distribution of the state after quantum phase estimation
    :param int_factor: an integer whose order will be computed by the quantum order finding algorithm
    :return: a factor of d
    here it will print the computation process such as ord(4 mod 15) = 2 and the factorization such as 15 = 3 * 5,
    where &quot;not quantum&quot; means the current factorization comes from a classical part of Shor&apos;s algorithm.
    For int_shots &gt; 2, we will print the number of shots where we obtain a correct factorization.
    &quot;&quot;&quot;</span>
    <span class="token comment"># Some classical cases</span>
    <span class="token keyword">if</span> int_divisor <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        int_divisor <span class="token operator">=</span> <span class="token operator">-</span>int_divisor
    <span class="token keyword">if</span> int_divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is zero.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">if</span> int_divisor <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is unit.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">elif</span> isprime<span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0} is prime.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># The case that d is a power of some prime</span>
        <span class="token keyword">for</span> idx_int <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> idx_int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> idx_int<span class="token punctuation">)</span> <span class="token operator">==</span> int_divisor<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0[0]} is a power of {0[1]}.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> idx_int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> idx_int
        <span class="token comment"># The case that d is even</span>
        <span class="token keyword">if</span> int_divisor <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0[0]} = {0[1]} * {0[2]}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> int_divisor <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">2</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># Generate a random f (int_factor) which can be assigned when called</span>
            <span class="token keyword">if</span> int_factor <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                int_factor <span class="token operator">=</span> randint<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> int_divisor <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token comment"># If the input int_factor is invalid to introduce the factorization, we reset the value of int_factor</span>
            <span class="token keyword">elif</span> int_factor <span class="token operator">%</span> int_divisor <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> int_factor <span class="token operator">%</span> int_divisor <span class="token operator">==</span> int_divisor <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">or</span> \
                    int_factor <span class="token operator">%</span> int_divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;The value of int_factor is invalid!&apos;</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span> int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
            int_gcd <span class="token operator">=</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
            <span class="token comment"># The case that f and d are not co-prime</span>
            <span class="token keyword">if</span> int_gcd <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;{0[0]} = {0[1]} * {0[2]}, not quantum&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> int_gcd<span class="token punctuation">,</span> int_divisor <span class="token operator">//</span> int_gcd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> int_gcd
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># From now on, we entry the quantum part</span>
                number_qubit_system <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment"># The number_qubit_ancilla used for phase estimation should be 2 * n_q_s + 4 such that the successful</span>
                <span class="token comment"># probability of the phase estimation will &gt; 98.6%</span>
                <span class="token keyword">if</span> number_qubit_ancilla <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    number_qubit_ancilla <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> number_qubit_system <span class="token operator">+</span> <span class="token number">4</span>
                <span class="token comment"># The case that the number of ancilla is enough</span>
                <span class="token keyword">if</span> number_qubit_ancilla <span class="token operator">&gt;=</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">:</span>
                    <span class="token comment"># A dict storing the possible order and its corresponding number of shots</span>
                    dict_order <span class="token operator">=</span> func_quantum_order_finding<span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_shots<span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">)</span>
                    <span class="token comment"># The list of possible order</span>
                    list_order <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>idx_key<span class="token punctuation">)</span> <span class="token keyword">for</span> idx_key <span class="token keyword">in</span> dict_order<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                    int_order <span class="token operator">=</span> <span class="token number">0</span>
                    <span class="token keyword">if</span> int_shots <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> int_shots <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_order<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                        <span class="token keyword">if</span> int_shots <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_order<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                            int_order <span class="token operator">=</span> list_order<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                        <span class="token keyword">elif</span> int_shots <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_order<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
                            <span class="token comment"># For two shots, we compute the least common multiple as the order</span>
                            int_order <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>list_order<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> list_order<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>list_order<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list_order<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        int_pow_half <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                        <span class="token comment"># To check whether int_factor and its order can introduce the factorization</span>
                        <span class="token keyword">if</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> int_order <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> int_pow_half <span class="token operator">!=</span> \
                                int_divisor <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">and</span> int_pow_half <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;ord({0[0]} mod {0[1]}) = {0[2]}&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token comment"># An f which satisfies some appropriate conditions will give a factorization of d</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;{0[0]} = {0[1]} * {0[2]}&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">return</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># Maybe we compute a wrong order, maybe f and its order cannot give the factorization of d</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;Perhaps ord({0[0]} mod {0[1]}) = {0[2]},\n&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span>
                                                                                       int_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;but it cannot give the factorization of {0}.&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token comment"># We haven&apos;t compute the correct order and need to recompute</span>
                            func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
                    <span class="token keyword">elif</span> int_shots <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
                        <span class="token comment"># Here we use sympy to compute the order to confirm which possible order is correct</span>
                        int_order_true <span class="token operator">=</span> n_order<span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                        <span class="token keyword">if</span> int_order_true <span class="token keyword">in</span> list_order<span class="token punctuation">:</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;We obtain ord({0[0]} mod {0[1]}) = {0[2]} for {0[3]} of {0[4]} times.&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_order_true<span class="token punctuation">,</span> dict_order<span class="token punctuation">[</span><span class="token string">&quot;{0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_order_true<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                                 int_shots<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            int_pow_half_true <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order_true <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                            <span class="token comment"># To check whether int_factor and its order can introduce the factorization</span>
                            <span class="token keyword">if</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_pow_half_true<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> int_order_true <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> \
                                    int_pow_half_true <span class="token operator">!=</span> int_divisor <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;{0[0]} = {0[1]} * {0[2]}&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>
                                    int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">return</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># int_factor cannot introduce the factorization of d</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&apos;But it cannot give the factorization of {0}.&apos;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                    int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># We haven&apos;t compute the correct order and need to recompute</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;we haven&apos;t computed the correct order of {0[0]} mod {0[1]}.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># The case that the number of ancilla is not enough, where the cost is more.</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Since the ancilla qubits are not enough to estimate the order with a high probability,&quot;</span><span class="token punctuation">)</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;we need to traverse all probable denominator in the step of continued fraction expansions.&quot;</span><span class="token punctuation">)</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Thus some order may be obtained for twice as many times as the number of shots.\n&quot;</span><span class="token punctuation">)</span>
                    <span class="token comment"># A dict storing the possible order and its corresponding number of shots</span>
                    dict_order <span class="token operator">=</span> func_quantum_order_finding<span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_shots<span class="token punctuation">,</span> number_qubit_ancilla<span class="token punctuation">)</span>
                    <span class="token comment"># The list of possible order</span>
                    list_order <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>idx_key<span class="token punctuation">)</span> <span class="token keyword">for</span> idx_key <span class="token keyword">in</span> dict_order<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                    int_order <span class="token operator">=</span> <span class="token number">0</span>
                    <span class="token keyword">if</span> int_shots <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_order<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># For the case 1-shot</span>
                        <span class="token keyword">for</span> int_order_maybe <span class="token keyword">in</span> list_order<span class="token punctuation">:</span>  <span class="token comment"># Check &quot;maybe&quot; is the correct order one by one</span>
                            <span class="token keyword">if</span> int_order_maybe <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order_maybe<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                                int_order <span class="token operator">=</span> int_order_maybe  <span class="token comment"># If correct, recorded in int_order</span>
                                <span class="token keyword">break</span>
                        int_pow_half <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                        <span class="token comment"># To check whether int_factor and its order can introduce the factorization</span>
                        <span class="token keyword">if</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> int_order <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> int_pow_half <span class="token operator">!=</span> \
                                int_divisor <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">and</span> int_pow_half <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;ord({0[0]} mod {0[1]}) = {0[2]}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token comment"># An f which satisfies some appropriate conditions will give a factorization of d</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0[0]} = {0[1]} * {0[2]}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">return</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># Maybe we compute a wrong order, maybe f and its order cannot give the factorization of d</span>
                            <span class="token keyword">if</span> int_order <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># We haven&apos;t computed the correct order of int_factor</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;We haven&apos;t computed the correct order of {0[0]} mod {0[1]}.\n&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                    <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># int_factor cannot introduce the factorization of d</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Perhaps ord({0[0]} mod {0[1]}) = {0[2]},&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                    <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;but it cannot give the factorization of {0}.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token comment"># And we need to recompute</span>
                            func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
                    <span class="token keyword">elif</span> int_shots <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># For the case int_shots &gt; 1</span>
                        <span class="token comment"># Here we use sympy to compute the order to confirm which possible order is correct</span>
                        int_order_true <span class="token operator">=</span> n_order<span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                        <span class="token keyword">if</span> int_order_true <span class="token keyword">in</span> list_order<span class="token punctuation">:</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;We obtain ord({0[0]} mod {0[1]}) = {0[2]} for {0[3]} of {0[4]} times.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">,</span> int_order_true<span class="token punctuation">,</span> dict_order<span class="token punctuation">[</span><span class="token string">&quot;{0}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_order_true<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                                 int_shots<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            int_pow_half_true <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_order_true <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span>
                            <span class="token comment"># To check whether int_factor and its order can introduce the factorization</span>
                            <span class="token keyword">if</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>int_factor<span class="token punctuation">,</span> int_pow_half_true<span class="token punctuation">,</span> int_divisor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> int_order_true <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> \
                                    int_pow_half_true <span class="token operator">!=</span> int_divisor <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;{0[0]} = {0[1]} * {0[2]}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">[</span>int_divisor<span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>
                                    int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                <span class="token keyword">return</span> math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> int_pow_half_true <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># int_factor cannot introduce the factorization of d</span>
                                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;But it cannot give the factorization of {0}.&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>int_divisor<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                    int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># We haven&apos;t compute the correct order and need to recompute</span>
                            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;we haven&apos;t computed the correct order of {0[0]} mod {0[1]}.\n&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
                                <span class="token punctuation">[</span>int_factor<span class="token punctuation">,</span> int_divisor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                            func_Shor_algorithm<span class="token punctuation">(</span>int_divisor<span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span>number_qubit_ancilla<span class="token punctuation">,</span>
                                                int_shots<span class="token operator">=</span>int_shots<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>We denote the integer <span class="mathjax-exps">$N$</span> to be factored as <code>int_divisor</code>, the integer <span class="mathjax-exps">$a\in\{2,\cdots,N-2\}$</span> selected in the first iteration as <code>int_factor</code> and to be randomly generated in the <code>38th</code> line by default, the number of ancilla qubits in quantum phase estimation algorithm as <code>number_qubit_ancilla</code> to be set a little larger than twice the number of qubits encoding <span class="mathjax-exps">$N$</span> in the <code>55th</code> line by default, and the operation times of each quantum circuit as <code>int_shots</code> to be set <span class="mathjax-exps">$2$</span> corresponding to the step 2 in algorithm 7 by default.</p>
<p>We reduce the cases for <span class="mathjax-exps">$N$</span> negative, <span class="mathjax-exps">$0$</span>, <span class="mathjax-exps">$1$</span>, prime, even, powers of integers in the <code>14-35th</code> lines of the above codes, corresponding to the input condition in algorithm 3. The <code>37-49th</code> lines are corresponding to the step 1-3 of algorithm 3. Then there&apos;re also two cases to distinguish whether the ancilla qubits are enough. If the ancilla qubits are enough or the shots number <span class="mathjax-exps">$\le 2$</span>, we prefer trying to factor <span class="mathjax-exps">$N$</span>; otherwise, we prefer estimating the probability of obtaining correct factorization. We achieve the result from quantum order-finding algorithm in the <code>60th</code> or <code>119th</code> line. For the case trying to factor <span class="mathjax-exps">$N$</span>, we determine whether <span class="mathjax-exps">$a$</span> is an inducer in the <code>72nd</code> or <code>130th</code> line, corresponding to the step 5 in algorithm 3, and furtherly give the factorization in the <code>76th</code> or <code>134th</code> line. For the case estimating probabilities, we call function <code>sympy.ntheory.residue_ntheory.n_order</code> to obtain correct order directly in <code>90th</code> and <code>152nd</code> line, and then compare it with the result from quantum order-finding algorithm to obtain the frequency for obtaining correct factorization.</p>
<p>We can call Shor&apos;s algorithm as follows:</p>
<pre data-role="codeBlock" data-info="python" class="language-python">func_Shor_algorithm<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> number_qubit_ancilla<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> int_shots<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> int_factor<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
</pre><p>The results of a run are following:</p>
<pre data-role="codeBlock" data-info="python" class="language-python">Shots <span class="token number">2</span>
Counts <span class="token punctuation">{</span><span class="token string">&apos;00000010&apos;</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&apos;00000001&apos;</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
State <span class="token boolean">None</span>
Seed <span class="token number">245569767</span>
<span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token number">2</span> mod <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token number">15</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">5</span>
</pre><p>We can see that the quantum order-finding algorithm finds the correct order of <span class="mathjax-exps">$2$</span> modulo <span class="mathjax-exps">$15$</span>.</p>
<h2 class="mume-header" id="reference">Reference</h2>

<p>[1] Pomerance, Carl. &quot;A tale of two sieves.&quot; Notices Amer. Math. Soc. 1996.</p>
<p>[2] Shor, Peter W. &quot;Algorithms for quantum computation: discrete logarithms and factoring.&quot; Proceedings 35th annual symposium on foundations of computer science. IEEE, 1994.</p>
<p>[3] Agrawal, Manindra, Neeraj Kayal, and Nitin Saxena. &quot;PRIMES is in P.&quot; Annals of Mathematics (2004): 781-793.</p>
<p>[4] Lenstra Jr, H. W., and Carl Pomerance. &quot;Primality testing with Gaussian periods. Archived version 20110412, Dartmouth College, US.&quot; (2011).</p>
<p>[5] Nielsen, Michael A., and Isaac L. Chuang. &quot;Quantum computation and quantum information.&quot; Phys. Today 54.2 (2001): 60.</p>
<p>[6] Vedral, Vlatko, Adriano Barenco, and Artur Ekert. &quot;Quantum networks for elementary arithmetic operations.&quot; Physical Review A 54.1 (1996): 147.</p>
<p>[7] Beauregard, Stephane. &quot;Circuit for Shor&apos;s algorithm using 2n+3 qubits.&quot; arXiv preprint quant-ph/0205095 (2002).</p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>