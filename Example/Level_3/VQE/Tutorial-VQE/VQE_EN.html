<!DOCTYPE html><html><head>
      <title>VQE_EN</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({"extensions":["tex2jax.js"],"jax":["input/TeX","output/HTML-CSS"],"messageStyle":"none","tex2jax":{"processEnvironments":false,"processEscapes":true,"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"TeX":{"extensions":["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]},"HTML-CSS":{"availableFonts":["TeX"]}});
        </script>
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h2 class="mume-header" id="variational-quantum-eigensolver-vqe">Variational Quantum Eigensolver (VQE)</h2>

<p>Consider the following question: how to find the smallest eigenvalue of a Hermitian matrix <span class="mathjax-exps">$H$</span>? This question is important for physics and quantum chemistry. For an atomic level system, there is a Hamiltonian <span class="mathjax-exps">$H$</span>, which is a Hermitian matrix, that describes the system&#x2019;s characteristics and behaviors. By finding the smallest eigenvalue of <span class="mathjax-exps">$H$</span> and its corresponding eigenvectors, we can find the ground energy and state of this system. VQE is a quantum technique designed to handle this task. The idea behind VQE is amazingly simple and easy to understand. Suppose <span class="mathjax-exps">$\lambda_\text{min}$</span> is the smallest eigenvalue of a Hamiltonian <span class="mathjax-exps">$H$</span>. Then for every quantum state <span class="mathjax-exps">$\lvert {\phi}\rangle$</span>,<br>
</p><div class="mathjax-exps">$$\langle{\phi} \lvert H\lvert {\phi}\rangle \ge \lambda_\text{min}.$$</div><br>
The core of VQE is to minimize <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span> by adjusting <span class="mathjax-exps">$\lvert {\phi}\rangle$</span>, and thus to estimate <span class="mathjax-exps">$\lambda_\text{min}$</span> the ground energy of the system. Now, let&#x2019;s learn more about details about VQE, including how to adjust <span class="mathjax-exps">$|\phi\rangle$</span> and how to compute <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span>.<p></p>
<h3 class="mume-header" id="parameterized-quantum-circuit">Parameterized Quantum Circuit</h3>

<p>To adjust a quantum state <span class="mathjax-exps">$\lvert {\phi}\rangle$</span>, we need to build a parameterized quantum circuit.</p>
<p><img src="./pic/VQE4.png" alt="VQE4.png"></p>
<p>The figure above shows a 2-qubit quantum circuit controlled by 4 parameters. By adjusting the 4 parameters, we can change the output state of the circuit given a fixed input state. Certainly, you can build a more complex parameterized quantum circuit.</p>
<p><img src="./pic/VQE12.png" alt="VQE12.png"></p>
<p>The figure above shows a 5-qubit quantum circuit with 12 parameters. Still, by adjusting those parameters, we can change the output state. Some readers may wonder that, given a fixed input state, whether a parameterized circuit can output an arbitrary quantum state. That depends on the structre of a parameterized circuit. For a 2-qubit system, we can build a parameterized with 15 parameters, shown in the figure below.</p>
<p><img src="./pic/VQE15.png" alt="VQE15.png"></p>
<p>By adjusting those 15 parameters, we can generate an arbitrary 2-qubit state. Generally, it is not only hard, but impractical to design a parameterized quantum circuit that can generate any possible quantum state. In practice, we only need a quantum state <span class="mathjax-exps">$|\phi\rangle$</span> close enough to the ground state <span class="mathjax-exps">$|\phi_{\lambda_\text{min}}\rangle$</span> to make a good estimation of <span class="mathjax-exps">$\lambda_{min}$</span>.</p>
<p>Now that we understand how to adjust <span class="mathjax-exps">$\lvert {\phi}\rangle$</span> with a parameterized quantum circuit, let&#x2019;s keep on and learn to use quantum circuits to compute <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span>, the expectation value of <span class="mathjax-exps">$H$</span> under state <span class="mathjax-exps">$|\phi\rangle$</span>.</p>
<h3 class="mume-header" id="pauli-measurement">Pauli Measurement</h3>

<p>Usually, we decompose <span class="mathjax-exps">$H$</span> into a linear combination of multiple Hamiltonians <span class="mathjax-exps">$H_i$</span> with simpler structures. That is,<br>
</p><div class="mathjax-exps">$$H = \sum_i c_iH_i,$$</div><br>
where <span class="mathjax-exps">$c_i$</span> is a complex coefficient. For each <span class="mathjax-exps">$H_i$</span>, the expectation value <span class="mathjax-exps">$\langle\phi|H_i|\phi\rangle$</span> is easy to compute. After computing <span class="mathjax-exps">$\langle\phi|H_i|\phi\rangle$</span> for all <span class="mathjax-exps">$H_i$</span>, we get <span class="mathjax-exps">$\langle\phi|H|\phi\rangle$</span> through<br>
<div class="mathjax-exps">$$\langle{\phi} \lvert H\lvert {\phi}\rangle = \sum_i c_i\langle{\phi} \lvert H_i\lvert {\phi}\rangle.$$</div><p></p>
<p>In many cases, <span class="mathjax-exps">$H$</span> can be decomposed into <span class="mathjax-exps">$O(\text{poly}(n))$</span> number of <span class="mathjax-exps">$H_i$</span>, where n is the number of qubit. Each <span class="mathjax-exps">$H_i$</span> is a tensor product of Pauli matrices, e.g., <span class="mathjax-exps">$\sigma_x\otimes I\otimes\sigma_z\otimes\cdots\otimes \sigma_y$</span>. To be precise,<br>
</p><div class="mathjax-exps">$$H_i \in \{I, \sigma_x, \sigma_y, \sigma_z\}^{\otimes n}.$$</div><br>
where <span class="mathjax-exps">$I$</span> is the identity matrix, and <span class="mathjax-exps">$\sigma_x, \sigma_y, \sigma_z$</span> are the Pauli matrices. In theory, any Hermitian <span class="mathjax-exps">$H$</span> can be written as a linear combination of tensor products of Pauli matrices. Since to get <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span> we need to compute every <span class="mathjax-exps">$\langle\phi|H_i|\phi\rangle$</span>, how do we compute <span class="mathjax-exps">$\langle\phi|H_i|\phi\rangle$</span> in practice? This computation can be done with a technique called Pauli measurement. Let&#x2019;s go through a simple example.<p></p>
<p>To begin with, we use the following circuit to prepare a 3-qubit quantum state <span class="mathjax-exps">$\lvert {\phi}\rangle$</span>.<br>
<img src="./pic/pauli1.png" alt="pauli1.png"></p>
<p>Suppose we want to get the value <span class="mathjax-exps">$\langle{\phi} \lvert \sigma_x\otimes \sigma_y\otimes\sigma_z\lvert {\phi}\rangle$</span>, so we build a circuit like the one in the figure below and run it for several times.<br>
<img src="./pic/pauli2-EN.png" alt="pauli2-EN.png"><br>
Notice that we add an ancilla qubit <span class="mathjax-exps">$q_0$</span> to our circuit. The purpose of this extra qubit is to help us compute the value of <span class="mathjax-exps">$\langle{\phi} \lvert \sigma_x\otimes \sigma_y\otimes\sigma_z\lvert {\phi}\rangle$</span>. Also notice that we append a new part to the circuit which contains gates including Hadamard&#x200B; gates and a <span class="mathjax-exps">$R_z(-\pi/2)$</span> gate. This new part of circuit is another trick to get <span class="mathjax-exps">$\langle{\phi} \lvert \sigma_x\otimes \sigma_y\otimes\sigma_z\lvert {\phi}\rangle$</span>. For different <span class="mathjax-exps">$H_i$</span> we need to build different circuits, which we will discuss later. We run the circuit, measure the ancilla, records the result (0 or 1), and repeat the process multiple times. By recording the <strong>frequency</strong> of 0 and 1, we can calculate the <strong>probability</strong> of getting 0 and 1:<br>
</p><div class="mathjax-exps">$$\text{The value of }\langle{\phi} \lvert \sigma_x\otimes \sigma_y\otimes\sigma_z\lvert {\phi}\rangle \approx \\ \text{The probability of getting 0} - \text{The probability of getting 1}$$</div><br>
The more you repeat, the more accurate your result will be. We have just learned how different <span class="mathjax-exps">$H_i$</span> have different circuits associate with them. Let me show you what the circuit look like if <span class="mathjax-exps">$H_i = \sigma_z\otimes \sigma_x\otimes I$</span>:<br>
<img src="./pic/pauli3.png" alt="pauli3.png"><br>
See? The second part of the circuit changed and the rest remains the same. We still run the circuit multiple times, measure the ancilla each time, record the result, and repeat the same procedure to calculate the probability of getting 0 minus the probability of getting 1, which is very close to <span class="mathjax-exps">$\langle{\phi} \lvert \sigma_z\otimes \sigma_x\otimes I\lvert {\phi}\rangle$</span>. Of course, the more it repeats, the closer the result gets. There are some rules you need to follow:<p></p>
<ul>
<li><span class="mathjax-exps">$\sigma_x\to$</span> <span class="mathjax-exps">$Hadamard$</span> gate + <span class="mathjax-exps">$CNOT$</span> gate</li>
<li><span class="mathjax-exps">$\sigma_y\to$</span> <span class="mathjax-exps">$R_z(-\pi/2)$</span>gate + <span class="mathjax-exps">$Hadamard$</span> gate + <span class="mathjax-exps">$CNOT$</span> gate</li>
<li><span class="mathjax-exps">$\sigma_z\to$</span> <span class="mathjax-exps">$CNOT$</span> gate</li>
<li><span class="mathjax-exps">$I \to$</span> add nothing</li>
</ul>
<p>Have you seen patterns from the circuit that corresponds with <span class="mathjax-exps">$\sigma_x\otimes \sigma_y\otimes\sigma_z$</span>? We add a <span class="mathjax-exps">$Hadamard$</span> gate on <span class="mathjax-exps">$q_1$</span> and a <span class="mathjax-exps">$CNOT$</span> gate, because the first item in <span class="mathjax-exps">$\sigma_x\otimes \sigma_y\otimes\sigma_z$</span> is <span class="mathjax-exps">$\sigma_x$</span>; we add a <span class="mathjax-exps">$R_z(-\pi/2)$</span> gate, <span class="mathjax-exps">$Hadamard$</span> gate on <span class="mathjax-exps">$q_2$</span> and a <span class="mathjax-exps">$CNOT$</span> gate. That is because the second part of <span class="mathjax-exps">$\sigma_x\otimes \sigma_y\otimes\sigma_z$</span> is <span class="mathjax-exps">$\sigma_y$</span>. We only add a <span class="mathjax-exps">$CNOT$</span> gate on <span class="mathjax-exps">$q_3$</span> because the third part is <span class="mathjax-exps">$\sigma_z$</span>. Now, let&#x2019;s figure out the circuit associated with<span class="mathjax-exps">$\sigma_z\otimes \sigma_x\otimes I$</span>:</p>
<p>Apply <span class="mathjax-exps">$CNOT$</span> gate onto <span class="mathjax-exps">$q_1$</span>, because the first part of <span class="mathjax-exps">$\sigma_z\otimes \sigma_x\otimes I$</span> is <span class="mathjax-exps">$\sigma_z$</span>; <span class="mathjax-exps">$Hadamard$</span> gate and <span class="mathjax-exps">$CNOT$</span> gate are applied onto <span class="mathjax-exps">$q_2$</span>, because the second part is <span class="mathjax-exps">$\sigma_x$</span>; add nothing on <span class="mathjax-exps">$q_3$</span>, because the third part is <span class="mathjax-exps">$I$</span>. Let&#x2019;s take a quiz, what is the circuit that measures <span class="mathjax-exps">$\langle{\phi} \lvert \sigma_y\otimes I\otimes \sigma_y\lvert {\phi}\rangle$</span> ? The answer is in the figure below:<br>
<img src="./pic/pauli4.png" alt="pauli4.png"></p>
<p>Not surprisingly, we get all gradients to get the value <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span>, where<br>
</p><div class="mathjax-exps">$$H = 0.5*\sigma_x\otimes \sigma_y\otimes\sigma_z + 0.2*\sigma_z\otimes \sigma_x\otimes I + 0.8 * \sigma_y\otimes I\otimes \sigma_y$$</div><br>
Just run the three circuit independently multiple times and record the measurement records on the ancilla. Calculate<span class="mathjax-exps">$\langle{\phi} \lvert H_i\lvert {\phi}\rangle$</span>, times the coefficient, add them up and we are done. I know it looks intimidating and complicated the first time you read this. Just read the previous part a few more times, and you will get it through. There is nothing incomprehensible in VQE.<p></p>
<h3 class="mume-header" id="gradient-descent">Gradient Descent</h3>

<p>After understanding the details of previous sections, we keep moving. Notice that the value you get is actually an approximation of <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span>. The more measurements, the more precise the result will be. Second of all, by adjusting the six parameters in the circuit, you get new values for <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span> every time. Isn&#x2019;t that interesting, it is a multivariate function! In fact, in almost all papers related to VQE, scholars unanimously view<span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span> as a multivariate function.</p>
<p></p><div class="mathjax-exps">$$L(\theta_1, \theta_2,\cdots, \theta_m) \\= \langle{\phi(\theta_1, \theta_2,\cdots, \theta_m)} \lvert H\lvert {\phi(\theta_1, \theta_2,\cdots, \theta_m)}\rangle \\ =  \langle{00\cdots 0} \lvert U^\dagger(\theta_1, \theta_2,\cdots, \theta_m) HU(\theta_1, \theta_2,\cdots, \theta_m)\lvert {00\cdots 0}\rangle$$</div><p></p>
<p>where <span class="mathjax-exps">$U(\theta_1, \theta_2,\cdots, \theta_m)$</span> is the matrix representation of the parameterized circuit. If you do view it as a multivariate function, the problem of finding the smallest eigenvalue of <span class="mathjax-exps">$H$</span> is equivalent to finding the minimum value of <span class="mathjax-exps">$L(\theta_1, \theta_2,\cdots, \theta_m)$</span>. Let&#x2019;s do a brief recap. We want to find the smallest eigenvalue of a Hermitian <span class="mathjax-exps">$H$</span>, so we decompose it to a linear summation of <span class="mathjax-exps">$H_i$</span>, tensor product of Pauli matrices and identity matrices. We build a parameterized circuit and apply appropriate gates in the end according to the rules for each <span class="mathjax-exps">$H_i$</span>, measure the ancilla multiple times for each circuit, calculate <span class="mathjax-exps">$\langle{\phi} \lvert H_i\lvert {\phi}\rangle$</span> and add them back to get an approximation of <span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span><br>
</p><div class="mathjax-exps">$$L(\theta_1, \theta_2, \cdots \theta_m) = \langle{\phi} \lvert H\lvert {\phi}\rangle = \sum_i c_i\langle{\phi} \lvert H_i\lvert {\phi}\rangle$$</div><br>
You might realize that we can use Gradient Descend method to help us find the minimum value of <span class="mathjax-exps">$L(x_1, x_2, \cdots x_n)$</span>. Find a small number <span class="mathjax-exps">$\epsilon$</span>, and we can calculate the gradient of function <span class="mathjax-exps">$L$</span> by the following rule:<br>
<div class="mathjax-exps">$$\frac{\partial L}{\partial \theta_i} \approx \frac{L(\cdots,\theta_i+\epsilon, \cdots) - L(\cdots,\theta_i, \cdots)}{\epsilon}$$</div><br>
This is called finite-difference methods. Since it can yield extremely unstable result due to statistical error, we use a different way to get the gradient instead, and that is called analytical gradient method<br>
<div class="mathjax-exps">$$\frac{\partial L}{\partial \theta_i} = \frac{ L(\cdots,\theta_i+\pi/2, \cdots) - L(\cdots,\theta_i-\pi/2, \cdots)}{2}$$</div><br>
Thanks to the exotic structure of VQE, we get an equation instead of an approximate equation! Analytical gradient method is relatively stable. It became a basic method for VQE. After reading, get our hand dirty by coding on Quantum Leaf, shall we?<p></p>
<h3 class="mume-header" id="implement-vqe-with-qcompute">Implement VQE with QCompute</h3>

<p>Import the packages we need:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">from</span> copy <span class="token keyword">import</span> copy
<span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp
<span class="token keyword">import</span> pickle
<span class="token keyword">import</span> random
<span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span>
<span class="token keyword">from</span> os <span class="token keyword">import</span> path

<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> scipy
<span class="token keyword">import</span> scipy<span class="token punctuation">.</span>linalg
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt

<span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&apos;../../..&apos;</span><span class="token punctuation">)</span>  <span class="token comment"># &quot;from QCompute import *&quot; requires this</span>
<span class="token keyword">from</span> QCompute <span class="token keyword">import</span> <span class="token operator">*</span>
</pre><p>Set up parameters and hyper parameters:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token comment"># hyper-parameter setting</span>
shots <span class="token operator">=</span> <span class="token number">1024</span>
n <span class="token operator">=</span> <span class="token number">4</span>  <span class="token comment"># n must be larger than or equal to 2; n is the size of our quantum system</span>
<span class="token keyword">assert</span> n <span class="token operator">&gt;=</span> <span class="token number">2</span>
L <span class="token operator">=</span> <span class="token number">2</span>  <span class="token comment"># L is the number of layers</span>
iteration_num <span class="token operator">=</span> <span class="token number">20</span>
experiment_num <span class="token operator">=</span> <span class="token number">4</span>  <span class="token comment"># That&apos;s the number of parallel experiments we will run;</span>
<span class="token comment"># it indicates the number of processes we will use.</span>
<span class="token comment"># Don&apos;t stress your computer too much.</span>
learning_rate <span class="token operator">=</span> <span class="token number">0.3</span>
delta <span class="token operator">=</span> np<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">2</span>  <span class="token comment"># calculate analytical derivative</span>
SEED <span class="token operator">=</span> <span class="token number">36</span>  <span class="token comment"># This number will determine what the final Hamiltonian is. It is also</span>
<span class="token comment"># used to make sure Mac and Windows behave the same using multiprocessing module.</span>
K <span class="token operator">=</span> <span class="token number">3</span>  <span class="token comment"># k is the number of local hamiltonian in H</span>
N <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">*</span> L <span class="token comment"># N is the number of parameters needed for the circuit</span>
random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>SEED<span class="token punctuation">)</span>
</pre><p>It is a function that can generate random Hamiltonian:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">random_pauli_generator</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    The following functions are used to generate random Hamiltonian
    &quot;&quot;&quot;</span>

    s <span class="token operator">=</span> <span class="token string">&apos;&apos;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
        s <span class="token operator">=</span> s <span class="token operator">+</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&apos;i&apos;</span><span class="token punctuation">,</span> <span class="token string">&apos;x&apos;</span><span class="token punctuation">,</span> <span class="token string">&apos;y&apos;</span><span class="token punctuation">,</span> <span class="token string">&apos;z&apos;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> s

<span class="token keyword">def</span> <span class="token function">random_H_generator</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    n is the number of qubits, k is the number of local hamiltonian in H
    &quot;&quot;&quot;</span>

    H <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        H<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> random_pauli_generator<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> H


Hamiltonian <span class="token operator">=</span> random_H_generator<span class="token punctuation">(</span>n<span class="token punctuation">,</span> K<span class="token punctuation">)</span>  <span class="token comment"># our hamiltonian H</span>
</pre><p>It is a function that can calculate tensor product of multiple matrices. It is borrowed from <a href="https://github.com/PaddlePaddle/Quantum/blob/master/paddle_quantum/utils.py">Paddle Quantum</a>.</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token comment"># From Paddle_quantum package</span>
<span class="token keyword">def</span> <span class="token function">NKron</span><span class="token punctuation">(</span>AMatrix<span class="token punctuation">,</span> BMatrix<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    Recursively execute kron n times. This function at least has two matrices.
    :param AMatrix: First matrix
    :param BMatrix: Second matrix
    :param args: If have more matrix, they are delivered by this matrix
    :return: The result of tensor product.
    &quot;&quot;&quot;</span>

    <span class="token keyword">return</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span>
        <span class="token keyword">lambda</span> result<span class="token punctuation">,</span> index<span class="token punctuation">:</span> np<span class="token punctuation">.</span>kron<span class="token punctuation">(</span>result<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">,</span>
        args<span class="token punctuation">,</span>
        np<span class="token punctuation">.</span>kron<span class="token punctuation">(</span>AMatrix<span class="token punctuation">,</span> BMatrix<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>
</pre><p>This a function that calculates the smallest eigenvalue of a Hermitian matrix:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">ground_energy</span><span class="token punctuation">(</span>Ha<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    It returns the ground energy of hamiltonian Ha,
    which looks like [[12, &apos;xyiz&apos;], [21, &apos;zzxz&apos;], [10, &apos;iixy&apos;]].
    &quot;&quot;&quot;</span>

    <span class="token comment"># It is a local function</span>
    <span class="token keyword">def</span> <span class="token function">my_f</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>

        I <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0j</span>
        X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0j</span>
        Y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1j</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1j</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        Z <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0j</span>

        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">&apos;x&apos;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> X
        <span class="token keyword">elif</span> s <span class="token operator">==</span> <span class="token string">&apos;y&apos;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> Y
        <span class="token keyword">elif</span> s <span class="token operator">==</span> <span class="token string">&apos;z&apos;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> Z
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> I

    <span class="token comment"># It is a local function</span>
    <span class="token keyword">def</span> <span class="token function">my_g</span><span class="token punctuation">(</span>s_string<span class="token punctuation">)</span><span class="token punctuation">:</span>
        H <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> ele <span class="token keyword">in</span> s_string<span class="token punctuation">:</span>
            H<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_f<span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> NKron<span class="token punctuation">(</span><span class="token operator">*</span>H<span class="token punctuation">)</span>

    <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> ele <span class="token keyword">in</span> Ha<span class="token punctuation">:</span>
        <span class="token builtin">sum</span> <span class="token operator">+=</span> ele<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> my_g<span class="token punctuation">(</span>ele<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    eigen_vector <span class="token operator">=</span> np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>scipy<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>eig<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> eigen_vector<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real
</pre><p>This function is used to visualize our results:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">eigen_plot</span><span class="token punctuation">(</span>eigenv_list<span class="token punctuation">,</span> actual_eigenv<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    This is the plot function of actual loss over iterations.
    &quot;&quot;&quot;</span>

    <span class="token keyword">for</span> ele <span class="token keyword">in</span> eigenv_list<span class="token punctuation">:</span>
        plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ele<span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>

    plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span>actual_eigenv<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">&apos;black&apos;</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">&apos;-.&apos;</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">&apos;iteration&apos;</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">&apos;loss&apos;</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">&apos;Actual Loss Over Iteration&apos;</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</pre><p>This function processes the experiment results, calculates the probability of getting 0 minus the probability of getting 0 with the ancilla qubit:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">prob_calc</span><span class="token punctuation">(</span>data_dic<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    Measure the first (ancilla) qubit. Returns the value
    of &apos;the probability of getting 0&apos; minus &apos;the probability of getting 1&apos;.
    &quot;&quot;&quot;</span>

    sum_0 <span class="token operator">=</span> <span class="token number">0</span>
    sum_1 <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> data_dic<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            sum_0 <span class="token operator">+=</span> value
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            sum_1 <span class="token operator">+=</span> value
    <span class="token keyword">return</span> <span class="token punctuation">(</span>sum_0 <span class="token operator">-</span> sum_1<span class="token punctuation">)</span> <span class="token operator">/</span> shots
</pre><p>The flowing functions helps build a parameterized circuit:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">add_block</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> loc<span class="token punctuation">,</span> para<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    Add a RzRyRz gate block. Each block has 3 parameters.
    &quot;&quot;&quot;</span>

    RZ<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>loc<span class="token punctuation">]</span><span class="token punctuation">)</span>
    RY<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>loc<span class="token punctuation">]</span><span class="token punctuation">)</span>
    RZ<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>loc<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">add_layer</span><span class="token punctuation">(</span>para<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    add a layer, each layer has 3*n parameters. para is a 2-D numpy array
    &quot;&quot;&quot;</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        add_block<span class="token punctuation">(</span>q<span class="token punctuation">,</span> i<span class="token punctuation">,</span> para<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        CX<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    CX<span class="token punctuation">(</span>q<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</pre><p>Decompose <span class="mathjax-exps">$H$</span> into a linear summation of <span class="mathjax-exps">$H_i$</span>, implement corresponding circuit according to the rules:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">self_defined_circuit</span><span class="token punctuation">(</span>para<span class="token punctuation">,</span> hamiltonian<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    H is a list, for example, if H = 12*X*Y*I*Z + 21*Z*Z*X*Z + 10* I*I*X*Y,
    then parameter hamiltonian is [[12, &apos;xyiz&apos;], [21, &apos;zzxz&apos;], [10, &apos;iixy&apos;]](upper case or lower case are all fine).
    It returns the expectation value of H.
    &quot;&quot;&quot;</span>

    env <span class="token operator">=</span> QuantumEnvironment<span class="token punctuation">(</span><span class="token punctuation">)</span>
    env<span class="token punctuation">.</span>backend<span class="token punctuation">(</span>BackendName<span class="token punctuation">.</span>LocalBaiduSim2<span class="token punctuation">)</span>

    <span class="token comment"># the first qubit is ancilla</span>
    q <span class="token operator">=</span> <span class="token punctuation">[</span>env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

    hamiltonian <span class="token operator">=</span> <span class="token punctuation">[</span>symbol<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> symbol <span class="token keyword">in</span> hamiltonian<span class="token punctuation">]</span>
    high_D_para <span class="token operator">=</span> para<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>L<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment"># change 1-D numpy array to a 3-D numpy array</span>

    <span class="token comment"># set up our parameterized circuit</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        H<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># add parameterized circuit</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
        add_layer<span class="token punctuation">(</span>high_D_para<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># set up pauli measurement circuit</span>
        <span class="token keyword">if</span> hamiltonian<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&apos;x&apos;</span><span class="token punctuation">:</span>
            H<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CX<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">elif</span> hamiltonian<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&apos;z&apos;</span><span class="token punctuation">:</span>
            CX<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">elif</span> hamiltonian<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&apos;y&apos;</span><span class="token punctuation">:</span>
            RZ<span class="token punctuation">(</span><span class="token operator">-</span>np<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            H<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            CX<span class="token punctuation">(</span>q<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment"># measurement result</span>
    MeasureZ<span class="token punctuation">(</span><span class="token punctuation">[</span>env<span class="token punctuation">.</span>Q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    taskResult <span class="token operator">=</span> env<span class="token punctuation">.</span>commit<span class="token punctuation">(</span>shots<span class="token punctuation">,</span> fetchMeasure<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> prob_calc<span class="token punctuation">(</span>taskResult<span class="token punctuation">[</span><span class="token string">&apos;counts&apos;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</pre><p>This function calculates the gradient and updates parameters each time you call it:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">diff_fun</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> para<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    It calculates the gradient of f on para,
    update parameters according to the gradient, and return the updated parameters.
    &apos;para&apos; is a np.array.
    &quot;&quot;&quot;</span>

    para_length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>para<span class="token punctuation">)</span>
    gradient <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>para_length<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>para_length<span class="token punctuation">)</span><span class="token punctuation">:</span>
        para_copy_plus <span class="token operator">=</span> copy<span class="token punctuation">(</span>para<span class="token punctuation">)</span>
        para_copy_minus <span class="token operator">=</span> copy<span class="token punctuation">(</span>para<span class="token punctuation">)</span>
        para_copy_plus<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> delta
        para_copy_minus<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> delta

        gradient<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">(</span>para_copy_plus<span class="token punctuation">)</span> <span class="token operator">-</span> f<span class="token punctuation">(</span>para_copy_minus<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>

    new_para <span class="token operator">=</span> copy<span class="token punctuation">(</span>para<span class="token punctuation">)</span>
    res <span class="token operator">=</span> new_para <span class="token operator">-</span> learning_rate <span class="token operator">*</span> gradient
    <span class="token keyword">return</span> res
</pre><p>Calculate<span class="mathjax-exps">$\langle{\phi} \lvert H\lvert {\phi}\rangle$</span>:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">loss_fun</span><span class="token punctuation">(</span>para<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    This is the loss function.
    &quot;&quot;&quot;</span>

    res <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span>ele<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> self_defined_circuit<span class="token punctuation">(</span>para<span class="token punctuation">,</span> ele<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> ele <span class="token keyword">in</span> Hamiltonian<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> res
</pre><p>Because we need to use multiprocessing package, we need some wrap up:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">multi_process_fun</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    This function runs one experiment, parameter j indicates it is the j-th experiment.
    &quot;&quot;&quot;</span>

    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token punctuation">)</span>
    para <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi
    para_list <span class="token operator">=</span> <span class="token punctuation">[</span>para<span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iteration_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
        para_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>diff_fun<span class="token punctuation">(</span>loss_fun<span class="token punctuation">,</span> para_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>outputPath<span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token string">f&quot;para</span><span class="token interpolation"><span class="token punctuation">{</span>j<span class="token punctuation">}</span></span><span class="token string">.pickle&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;wb&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
        pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>para_list<span class="token punctuation">,</span> fp<span class="token punctuation">)</span>
</pre><p>Finally we can run our main program:</p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    main
    &quot;&quot;&quot;</span>

    pool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>experiment_num<span class="token punctuation">)</span>
    pool<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>multi_process_fun<span class="token punctuation">,</span> <span class="token builtin">range</span><span class="token punctuation">(</span>experiment_num<span class="token punctuation">)</span><span class="token punctuation">)</span>
    loss_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>experiment_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
        actual_loss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>outputPath<span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token string">f&quot;para</span><span class="token interpolation"><span class="token punctuation">{</span>_<span class="token punctuation">}</span></span><span class="token string">.pickle&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;rb&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
            new_para_list <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>

        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iteration_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
            actual_loss<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss_fun<span class="token punctuation">(</span>new_para_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        loss_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>actual_loss<span class="token punctuation">)</span>

    eigen_plot<span class="token punctuation">(</span>loss_list<span class="token punctuation">,</span> ground_energy<span class="token punctuation">(</span>Hamiltonian<span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&apos;__main__&apos;</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</pre><p>Here is the figure that generated by one test of the whole program. Each thread is an independent process that makes 20 gradient descend iterations. Not so bad, eh?<br>
<img src="./pic/Figure_1.png" alt="Figure_1.png"></p>
<hr>
<h2 class="mume-header" id="reference">Reference</h2>

<p><a href="https://www.nature.com/articles/ncomms5213">Peruzzo, Alberto, et al. &#x201C;A variational eigenvalue solver on a photonic quantum processor.&#x201D; Nature communications 5 (2014): 4213.</a></p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>